<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Quads</title>
  <style>
    :root{ --bg:#fafafa; --ink:#111; --muted:#6b7280; --brand:#2563eb; --gold:#b45309; --purple:#6d28d9; --border:#e5e7eb; }

    /* variables controlling card size */
    :root{ --card-h: 60px; --card-w: 100px; --card-r: 10px; --card-bg:#fff; }

    /* When screen width ≤ 600px (e.g. phones) */
    @media (max-width: 600px) {
      :root { --card-h: 40px;  --card-w: 70px; --card-r: 7px; }
    }

    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .app{max-width:1100px;margin:0 auto;padding:16px}
    h1{margin:0 0 8px 0;font-size:20px}
    .status{color:var(--muted);font-size:13px;margin-bottom:8px;min-height:18px;}
    .tabs{display:flex;gap:8px;border-bottom:1px solid var(--border);margin-bottom:12px;flex-wrap:wrap}
    .tab-btn{appearance:none;border:0;background:transparent;padding:10px 14px;border-bottom:2px solid transparent;font-weight:700;color:var(--muted);cursor:pointer;border-radius:8px 8px 0 0}
    .tab-btn[aria-selected="true"]{color:var(--brand);border-color:var(--brand);background:#fff}
    .tab-panel{display:none}
    .tab-panel[aria-hidden="false"]{display:block}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin:8px 0}
    .pill{display:inline-flex;gap:8px;align-items:center;font-weight:700;background:#eef2ff;border:1px solid #e0e7ff;border-radius:999px;padding:6px 10px}
    label{font-weight:600}
    select,input[type=number]{padding:6px 8px;border:1px solid var(--border);border-radius:8px;background:#fff}
    button{padding:8px 12px;border:1px solid var(--border);border-radius:10px;background:#fff;cursor:pointer;font-weight:700}
    button.primary{background:var(--brand);border-color:var(--brand);color:#fff}

    .bin-container{display:flex;gap:16px;flex-wrap:wrap;align-items:flex-start}
    .bin-side{flex:1}

    .grid{display:grid;gap:8px;grid-template-columns:repeat(4, var(--card-w)); justify-content:center}

    .cell{border-radius:var(--card-r)}
    .card{background:var(--card-bg);border:1px solid var(--border);border-radius:var(--card-r);display:flex;align-items:center;justify-content:center;position:relative;overflow:hidden;cursor:pointer;height:var(--card-h);width:var(--card-w)}

    /* FRONT hidden unless face-up */
    .front{display:none; flex-direction:column; align-items:center; justify-content:center; width:100%;}
    .card.faceup .front{display:flex !important}
    .back{display:flex; justify-content:center; width:100%;}
    .card.faceup .back{display:none !important}

    .labels{display:none;font-size:12px;}

    .pic { display:flex; justify-content:center; width:100%; }
    /* try to use a consistent font across devices for symbols */
    .pic { font-family: "Times New Roman", "Segoe UI Symbol", "Noto Sans Symbols", "Arial Unicode MS", sans-serif; }
    .pic { font-size:14px; line-height:12px; vertical-align:middle; }
    .mini .pic { font-size:9px; }
    .pile .pic { font-size:9px; }

    /* Basis/Layout */
    .pile{display:flex;flex-wrap:wrap;gap:8px;padding:8px;min-height:124px;border:1px dashed var(--border);border-radius:12px;background:#fff}
    .badge{display:flex;align-items:center;justify-content:center;min-height:var(--card-h);border:2px dashed var(--border);border-radius:12px;background:#fff}
    .badge.basis{border-color:#c7d2fe;background:#eef2ff}
    .drop-ok{outline:3px solid var(--brand);outline-offset:2px}
    .backcard{background:var(--card);border:1px solid var(--border);border-radius:10px;height:60px;display:flex;align-items:center;justify-content:center;color:#9ca3af;width:var(--card-w)}
    .suggested{ box-shadow: inset 0 0 0 3px var(--brand); }
    /* Light blue shadow when a card sits in a basis position */
    .card.basis-manual { box-shadow: 0 0 0 4px #c7d2fe; }

    /* Phi map */
    .phiCell{cursor:pointer}
    .phiA{outline:2px solid rgba(217,119,6,0.35); outline-offset:2px; box-shadow:0 0 0 2px rgba(56, 48, 38, 0.1)}
    .phiB{outline:2px solid rgba(124,58,237,0.35); outline-offset:2px; box-shadow:0 0 0 2px rgba(124,58,237,0.10)}
    .phiSelectedA{outline:3px solid var(--gold) !important; box-shadow:0 0 10px 4px rgba(180,83,9,0.45) !important; border-radius:12px}
    .phiSelectedB{outline:3px solid var(--purple) !important; box-shadow:0 0 10px 4px rgba(109,40,217,0.45) !important; border-radius:12px}
    .a-shadow{outline:3px solid rgba(217,119,6,0.7); outline-offset:2px; box-shadow:0 0 0 3px rgba(217,119,0,0.18)}

    /* 50% size for cards in the Selected Pile */
    .pile .card { width: calc(var(--card-w) * 0.5); height: calc(var(--card-h) * 0.5); }
    .pile .backcard { width: calc(var(--card-w) * 0.5); height: calc(var(--card-h) * 0.5); }

    /* --- Find Quads --- */
    .card.hint { box-shadow: 0 0 0 3px #fbbf24; animation: hintPulse 0.9s ease-in-out 3 alternate; }
    @keyframes hintPulse {
      0% { transform: scale(1.0); }
      100% { transform: scale(1.04); }
    }
    
    .card.selected { outline:3px solid var(--brand); outline-offset:2px; }
    .found-wrap { display:flex; flex-wrap:wrap; gap:8px; grid-template-columns:repeat(auto-fill,minmax(210px,1fr)); }
    .found-quad { display:flex; gap:6px; padding:6px; border:1px solid var(--border); border-radius:12px; background:#fff; align-items:center; }

    /* 50% size for cards in the found quads section */
    .mini .card { width: calc(var(--card-w) * 0.5); height: calc(var(--card-h) * 0.5); }
    .mini .front { display:flex !important; } /* minis always show */
  </style>
</head>
<body>
  <div class="app">
    <h1>Quads — App</h1>
    <div id="status" class="status">(initializing…)</div>

    <div role="tablist" aria-label="Quads tabs" class="tabs">
      <button class="tab-btn" role="tab" id="tab-select" aria-controls="panel-select" aria-selected="true">Select Cards</button>
      <button class="tab-btn" role="tab" id="tab-layout" aria-controls="panel-layout" aria-selected="false">Basis / Layout</button>
      <button class="tab-btn" role="tab" id="tab-phi" aria-controls="panel-phi" aria-selected="false">Phi Map</button>
      <button class="tab-btn" role="tab" id="tab-find" aria-controls="panel-find" aria-selected="false">Find Quads</button>
    </div>

    <!-- Select Cards Panel -->
    <section id="panel-select" class="tab-panel" role="tabpanel" aria-labelledby="tab-select" aria-hidden="false">
      <div class="row">
        <span id="deckPill" class="pill"><label for="deckSize">Deck:</label>
        <select id="deckSize">
          <option value="64" selected>64</option>
          <option value="32">32</option>
          <option value="16">16</option>
        </select></span>
        <span class="pill"><span class="muted">Face-up</span> <strong id="selectUpCount">0 / 64</strong></span>
        <span class="pill"><span class="muted">Quads</span> <strong id="selectQuadCount">0</strong></span>
      </div>
      <div class="row">
        <span id="randomGroup" class="pill"><label for="nCount">Random N</label>
        <input id="nCount" type="number" value="12" min="1" max="64" />
        <button id="randomN">Apply</button></span>
        <span id="revealHidePill" class="pill">
          <button id="revealAll" class="primary">Reveal all</button>
          <button id="hideAll">Hide all</button>
          <span><input type="checkbox" id="showLabels">Show labels</span>
        </span>
      </div>

      <h3>Deck</h3>
      <div class="bin-container" id="bin-grids">
        <div class="bin-side"><div id="grid-left" class="grid"></div></div>
        <div class="bin-side"><div id="grid-right" class="grid"></div></div>
      </div>
    </section>

    <!-- Basis/Layout -->
    <section id="panel-layout" class="tab-panel" role="tabpanel" aria-labelledby="tab-layout" aria-hidden="true">
      <div class="row"><span id="basisGroup" class="pill">
        <button id="basisStartNew" class="primary">Create new basis</button>
        <button id="basisSuggestNext">Suggest Next</button>
        <div class="basis-msg">
          <span id="basisMsg" class="muted"></span>
        </div>
        </span>
        <button id="basisResetLayout">Return to Standard Layout</button>
        <span class="pill"><span class="muted">Face-up</span> <strong id="basisUpCount">0</strong></span>
        <span class="pill"><span class="muted">Quads</span> <strong id="basisQuadCount">0</strong></span>
      </div>

      <h3>Selected Pile</h3>
      <div id="basisPile" class="pile"></div>

      <h3 id="basisGridTitle">Grid</h3>
      <div class="bin-container" id="basis-grid">
        <div class="bin-side"><div id="basis-grid-left" class="grid"></div></div>
        <div class="bin-side"><div id="basis-grid-right" class="grid"></div></div>
      </div>
    </section>

    <!-- Phi Map -->
    <section id="panel-phi" class="tab-panel" role="tabpanel" aria-labelledby="tab-phi" aria-hidden="true">
      <div class="row"><span class="pill"><span class="muted">Partition</span>
          <select id="phiPartition">
            <option value="lr" selected>Left / Right</option>
            <option value="tb">Top / Bottom</option>
            <option value="rowsdbl">Double Rows</option>
            <option value="colsdbl">Double Cols</option>
            <option value="rowsAlt">Alternating Rows</option>
            <option value="colsAlt">Alternating Cols</option>
          </select>
        </span>
        <span id="phiActionPill" class="pill">
          <button id="phiStart" class="primary">Select Phi Map</button>
          <button id="phiUndo">Undo φ-map</button>
          <button id="phiApply">Apply</button>
          <button id="phiClearSel">Clear</button>
        </span>
        <span class="pill"><span class="muted">Quads before</span> <strong id="phiQuadBefore">0</strong></span>
        <span class="pill"><span class="muted">Quads after</span> <strong id="phiQuadAfter"></strong></span></div>
      <div id="phiInfo" class="muted" style="margin:.25rem 0;">Pick a face-up card for <b>b</b> from a purple (B) zone, then a face-down card for <b>a</b> from a gold (A) zone.</div>

      <h3 id="phiGridTitle">Phi Map Grid</h3>
      <div class="bin-container">
        <div class="bin-side"><div id="phi-grid-left" class="grid"></div></div>
        <div class="bin-side"><div id="phi-grid-right" class="grid"></div></div>
      </div>
    </section>

    <!-- Find Quads -->
    <section id="panel-find" class="tab-panel" role="tabpanel" aria-labelledby="tab-find" aria-hidden="true">
      <div class="row">
        <span class="pill"><span class="muted">Total quads (face-up)</span> <strong id="findTotalQuads">0</strong></span>
        <span class="pill"><span class="muted">Found</span> <strong id="findFoundCount">0 / 20</strong></span>
        <span class="pill">
          <button id="findClearSel">Clear selection</button>
          <button id="findResetList">Reset found list</button>
          <button id="findHint">Hint</button>
        </span>
      </div>

      <div id="findMsg" class="status"></div>

      <h3 id="findGridTitle">Find Quads Grid</h3>
      <div class="bin-container" id="find-grid">
        <div class="bin-side"><div id="find-grid-left" class="grid"></div></div>
        <div class="bin-side"><div id="find-grid-right" class="grid"></div></div>
      </div>

      <h3 style="margin-top:12px;">Found Quads</h3>
      <div id="foundQuadsWrap" class="found-wrap"></div>
    </section>
  </div>

<script>
// ---------- Utilities ----------
function byId(id){ return document.getElementById(id); }
function pad6(n){
  var s = (n || 0).toString(2);
  return ('000000' + s).slice(-6);
}
function decodeBits(bits){
  var color={"00":"#ef4444","01":"#10b981","10":"#f59e0b","11":"#3b82f6"}[bits.slice(0,2)];
  var shape={"00":'●',"01":'▲',"10":'■',"11":'♥'}[bits.slice(2,4)];
  var count={"00":1,"01":2,"10":3,"11":4}[bits.slice(4,6)];
  return {color:color,shape:shape,count:count};
}
function shapeSymbol(d) {
  // d.shape,d.color,d.count
  var el = document.createElement('div');
  el.className = 'pic';
  el.style.color = d.color;
  if (d.shape=='▲') el.style.letterSpacing = '-3px';  // triangle man, triangle man
  el.innerHTML = d.shape.repeat(d.count).trim();
  return el;
}

// ---------- Global state ----------
var DECK = 64;
var HALF = 32;
var deckSel, gridL, gridR;

function setAppStatus(t){
  statusEl = byId('status'); if (statusEl) statusEl.textContent = t || '';
}

// Select tab helpers
function allCards(){ 
  return document.querySelectorAll('#bin-grids .card');
}

function getCardEl(n){ 
  return ((n!=null) && (n>=0)) ? document.querySelector('#bin-grids .card[data-index="'+n+'"]') : null;
}

function isFaceUp(n){ 
  var el = getCardEl(n); if (el) return el.classList.contains('faceup');
  return false;
}

function setFaceUp(n, up){ 
  var el = getCardEl(n); if (el) el.classList.toggle('faceup', up);
}

function getSelectedIndicesSorted(){ 
  var out = []; 
  var cards = document.querySelectorAll('#bin-grids .card.faceup');
  for(var i=0;i<cards.length;i++){ 
    var idx = +cards[i].dataset.index; 
    out.push(idx);
  } 
  out.sort(function(a,b){return a-b;}); 
  return out;
}

// sorting is required so we can avoid an extra loop
function computeQuadsBasic(sortedIndices){
  var Uset = {}; for (var i=0;i<sortedIndices.length;i++) Uset[sortedIndices[i]] = 1;
  var cnt=0;
  for(var i=0;i<sortedIndices.length;i++){
    for(var j=i+1;j<sortedIndices.length;j++){
      for(var k=j+1;k<sortedIndices.length;k++){
        var a=sortedIndices[i], b=sortedIndices[j], c=sortedIndices[k], d=a^b^c;
        if (d>c && Uset[d]) cnt++;
      }
    }
  }
  return cnt;
}

function updateUpCount(up, quads){
  var uEl = byId('selectUpCount'); if (uEl) uEl.textContent = up.length + ' / ' + DECK;
  var qEl = byId('selectQuadCount'); if (qEl) qEl.textContent = quads; 
}



function makeFront(n){
  var bits=pad6(n), d=decodeBits(bits);
  var front=document.createElement('div'); 
  front.className='front';
  var pic=shapeSymbol(d);
  var labels=document.createElement('div'); 
  labels.className='labels';
  labels.textContent = bits;

  // NEW: honor the current checkbox when a card/front is created
  var cb = byId('showLabels');
  if (cb && cb.checked) labels.style.display = 'inline';

  front.appendChild(pic); 
  front.appendChild(labels);
  return front;
}

function makeBack(){
  var back=document.createElement('div'); 
  back.className='back';
  back.innerHTML='&Qopf;';
  back.style.color = '#9ca3af';
  back.style.fontSize = '22px';
  back.style.lineHeight = '22px';
  back.style.verticalAlign = 'middle';
  return back;
}

function makeCard(n){
  var cell=document.createElement('div'); 
  cell.className='cell';
  var card=document.createElement('div'); 
  card.className='card'; 
  card.dataset.index=+n;
  card.appendChild(makeFront(n)); 
  card.appendChild(makeBack());
  card.addEventListener('click', function(){ 
    card.classList.toggle('faceup'); 
    updateAppCounts(); buildPhiGridIfInit(); buildFindGridIfInit(); });
  cell.appendChild(card); 
  return cell;
}

function makeMiniCard(n){
  var mini=document.createElement('div'); 
  mini.className='mini';
  var card=document.createElement('div'); 
  card.className='card'; 
  card.appendChild(makeFront(n));
  mini.appendChild(card); 
  return mini;
}

function makeFaceDownPlaceholder(n){ 
  var ghost=makeBack();
  ghost.className='backcard'; 
  ghost.dataset.index=n; 
  return ghost;
}

function buildDeck(){
  if (!gridL || !gridR) return;
  gridL.innerHTML=''; 
  gridR.innerHTML='';
  for(var p=0;p<DECK;p++){ 
    var targetGrid = (p<HALF) ? gridL : gridR;
    targetGrid.appendChild(makeCard(p));
  }
  updateAppCounts();
}

function updateAppCounts(after){
  if (after == undefined)  after = false;
  var up = getSelectedIndicesSorted();
  var quads = computeQuadsBasic(up);
  updateUpCount(up, quads); 
  updateBasisStats(up, quads);
  if (after) { phi.quadsAfter = quads; } else { phi.quadsBefore = quads; }
  updatePhiQuadsDisplay();
  updateFindCounts(quads);
}

function wireSelectControls(){
  var reveal = byId('revealAll'); if (reveal) reveal.addEventListener('click', function(){ 
    var cards=allCards(); 
    for(var i=0;i<cards.length;i++) cards[i].classList.add('faceup'); 
    updateAppCounts(); refreshIfOnLayout(); buildPhiGridIfInit(); buildFindGridIfInit();
  });
  
  var hide = byId('hideAll'); if (hide) hide.addEventListener('click', function(){ 
    var cards=allCards(); 
    for(var i=0;i<cards.length;i++) cards[i].classList.remove('faceup'); 
    updateAppCounts(); refreshIfOnLayout(); buildPhiGridIfInit(); buildFindGridIfInit();
  });

  var showLabels = byId('showLabels'); showLabels.addEventListener('change', function(){ 
    var labels = document.querySelectorAll('.labels')
    labels.forEach(label => {
      label.style.display = showLabels.checked ? 'inline' : 'none';
    });
  });

  var hide=byId('hideAll'), rnd=byId('randomN');
  if (rnd) rnd.addEventListener('click', function(){
    var n=parseInt(byId('nCount').value || '0',10);  // get number of randoms, default to '0'  
    if (isNaN(n) || n<1) { n=1; } else if (n>DECK) { n=DECK; }  // sanity check n
    var set={}, count=0;
    while(count < n){
      var r = Math.floor(Math.random()*DECK);
      if (!set[r]) set[r]=1,count++;
    }
    var cards=allCards();
    for(var i=0;i<cards.length;i++) cards[i].classList.toggle('faceup', set[i]==1);
    updateAppCounts(); refreshIfOnLayout(); buildPhiGridIfInit(); buildFindGridIfInit();
  });
  deckSel.addEventListener('change', function(e){ 
    DECK = parseInt(e.target.value,10);
    HALF = (DECK==64 ? 32 : (DECK==32 ? 16 : DECK)); 
    buildDeck(); 
    basis.mappingComplete=false; 
    basis.pos2val=null; 
    basis.lockedPos2val=null; 
    refreshIfOnLayout(); 
    buildPhiGridIfInit(); 
    buildFindGridIfInit(); 
    updatePartitionDisables();
    resetFoundList();
  });
}

// Tabs
var tabs=[];
function activateTab(tabId){
  for(var k=0;k<tabs.length;k++){
    var B=tabs[k];
    var selected = (B.btn.id==tabId);
    B.btn.setAttribute('aria-selected', String(selected));
    B.panel.setAttribute('aria-hidden', String(!selected));
  }
  if (tabId=='tab-layout'){ ensureInitBasisTab(); refreshBasisEverything(); }
  if (tabId=='tab-phi'){ if (!phi.initialized) initPhiTab(); else buildPhiGrid(); }
  if (tabId=='tab-find'){ if (!find.initialized) initFindTab(); else buildFindGrid();
  }
}

// Boot
function init(){
  try{
    deckSel  = byId('deckSize');
    gridL    = byId('grid-left');
    gridR    = byId('grid-right');

    if (!deckSel || !gridL || !gridR){
      throw new Error('Missing Select tab markup.');
    }
    DECK = parseInt(deckSel.value, 10) || 64;
    HALF = (DECK==64 ? 32 : (DECK==32 ? 16 : DECK));

    tabs=[
      {btn:byId('tab-select'),panel:byId('panel-select')},
      {btn:byId('tab-layout'),panel:byId('panel-layout')},
      {btn:byId('tab-phi'),   panel:byId('panel-phi')},
      {btn:byId('tab-find'),  panel:byId('panel-find')}
    ];
    for(var t=0;t<tabs.length;t++){
      (function(T){ T.btn.addEventListener('click', function(){
        activateTab(T.btn.id);
      }); })(tabs[t]);
    }

    buildDeck();
    wireSelectControls();

    // Robust: wire Create New Basis globally
    var createBtn = byId('basisStartNew');
    if (createBtn){
      createBtn.addEventListener('click', function(e){
        activateTab('tab-layout');
        ensureInitBasisTab();
        startNewBasis();
      });
    }

    setAppStatus('Ready');
  } catch(err){
    setAppStatus('Init error: '+err.message);
    console.error(err);
  }
}
if (document.readyState=='loading'){ document.addEventListener('DOMContentLoaded', init); } else { init(); }

//==Basis/Layout==
var basis={ pile:null, gridL:null, gridR:null, pos2val:null, val2pos:null, mappingComplete:false, lockedPos2val:null };

function ensureInitBasisTab(){
  setBasisMsg();
  if (!basis.pile) initBasisTab();
}

function refreshIfOnLayout(){ if (tabs[1] && tabs[1].panel.getAttribute('aria-hidden')=='false'){ refreshBasisEverything(); } }

function makeBasisCell(i){ 
  var anchors=[0,1,2,4,8,16,32].filter(function(x){return x<DECK;}); 
  var d=document.createElement('div'); 
  d.className='cell badge'; 
  d.setAttribute('data-pos', i); 
  if (anchors.indexOf(i)!=-1) d.classList.add('basis');  // one of 7 basis positions
  return d;
}

function addBasisDataDnd(e, n, d) {
  e.dataTransfer.effectAllowed='move';
  e.dataTransfer.setData('data-index', String(n)); 
  var p=d.closest('.cell'); 
  if (p && p.hasAttribute('data-pos')){ 
    e.dataTransfer.setData('from','grid'); 
    e.dataTransfer.setData('fromPos', p.getAttribute('data-pos'));
  } else { 
    e.dataTransfer.setData('from','pile');
  }
}

function makeBasisCard(n){ 
  var d=document.createElement('div'); 
  d.className='card faceup'; 
  d.dataset.index=+n; 
  d.appendChild(makeFront(n));
  d.setAttribute('draggable','true'); 
  d.addEventListener('dragstart', function(e){ 
    addBasisDataDnd(e, n, d);
  });
  d.addEventListener('click', function(e){
    highlightSuggested(n,'Card selected.')
  });
  return d;
}

function basisCellAt(pos){
  if (pos==null || pos<0 || pos>=DECK) return null;
  if (!basis.gridL || !basis.gridR) return null;
  if (pos<HALF) return basis.gridL.children[pos] || null; 
  return basis.gridR.children[pos-HALF] || null;
}

function buildBasisGrid(){ 
  if (!basis.gridL || !basis.gridR) return; 
  basis.gridL.innerHTML=''; 
  basis.gridR.innerHTML='';
  for(var p=0;p<DECK;p++){ 
    var targetGrid = (p<HALF) ? basis.gridL : basis.gridR;
    targetGrid.appendChild(makeBasisCell(p));
  }
  byId('basisGridTitle').textContent='Grid ('+DECK+' places)'; 
  enableBasisDnD();
}

function refreshBasisPile(){
  if (!basis.pile) return; 
  var sel=getSelectedIndicesSorted(); 
  basis.pile.innerHTML=''; 
  for(var i=0;i<sel.length;i++) basis.pile.appendChild(makeBasisCard(sel[i]));
  updateAppCounts();
}

function resetBasisCell(pos){ 
  var cell = basisCellAt(pos); 
  if (!cell) return;
  // should only be one card, if any, and every card should have data-index
  var card=cell.querySelector('.card [data-index]');
  if (card && basis.pile){
    // if card (!backcard) in cell, move it to pile
    card.classList.remove('basis-manual');
    basis.pile.appendChild(card);  // will not add a dupe
  } 
  cell.innerHTML=''; 
  cell.classList.add('badge'); 
  cell.setAttribute('data-pos', String(pos)); 
}

function moveBasisCard(to, toPos, idx, from, fromPos) {
  // this handles pile->grid, grid->grid, and grid->pile moves
  // toPos and fromPos will be null for 'pile' types
  clearSuggested();

  // no destCell when moving to pile
  var destCell = basisCellAt(toPos);  
  if (destCell) destCell.classList.remove('drop-ok'); 
 
  // no srcCell when moving from pile
  var srcCell = basisCellAt(fromPos);
  if (srcCell) resetBasisCell(fromPos);  // temp put the card back on the pile

  // get card to be moved
  var card=basis.pile.querySelector('.card[data-index="'+idx+'"]'); 
  if (!card) return;

  // if dest is pile, it should already be there because of 
  // resetBasisCell(fromPos) above.
  // else if dest is cell (basis-grid)
  if (destCell) {
    resetBasisCell(toPos);  // this will move any card in dest to pile
    card.classList.add('basis-manual');  // add ring around card in basis pos
    destCell.appendChild(card);  // this will handle removeChild if in pile
  }

  // check if this triggers any auto changes
  basisAutoFill(); 
  scheduleclearBasisMsgOnNextClick();
  // If the pile is empty, auto-pick a random FACE-DOWN card for next anchor and complete spans.
  fillUntilCompleteFromFaceDown();
  // Now see if the mapping is complete and lock if so.
  checkAndLockPositions();
}

function enableBasisDnD(){ 
  // tbd ksh !!! for now allow allow dropping on anchors
  // for(var toPos=0;toPos<DECK;toPos++){
  [0,1,2,4,8,16,32].forEach(function(toPos) { 
    var destCell = basisCellAt(toPos); 
    // if (!destCell) continue; 
    if (!destCell) return; 
    // use IIFE to get new instance of toPos, destCell
    (function(toPos, destCell) {
      destCell.addEventListener('dragover', function(e){ e.preventDefault(); destCell.classList.add('drop-ok'); }); 
      destCell.addEventListener('dragleave', function(){ destCell.classList.remove('drop-ok'); }); 
      destCell.addEventListener('drop', function(e){ 
        // drag from pile->grid or grid->grid
        e.preventDefault(); 
        var idx = +e.dataTransfer.getData('data-index'); 
        var from = e.dataTransfer.getData('from');  // drag from grid or pile
        var fromPos = parseInt(e.dataTransfer.getData('fromPos') || '-1',10); 
        moveBasisCard('grid', toPos, idx, from, fromPos)
      }); 
      destCell.addEventListener('click', function(e){
        // click from pile->grid 
        var card = basis.pile.querySelector('.card.suggested');
        if (card) {
          var idx=+card.dataset.index;
          moveBasisCard('grid', toPos, idx, 'pile', null)
        }
      }); 
    })(toPos, destCell);
  });
  //} 
  basis.pile.addEventListener('dragover', function(e){ e.preventDefault(); }); 
  basis.pile.addEventListener('drop', function(e){
    // drag from grid->pile 
    e.preventDefault();
    var idx = +e.dataTransfer.getData('data-index'); 
    var fromPos = parseInt(e.dataTransfer.getData('fromPos') || '-1',10);
    moveBasisCard('pile', null, idx, 'grid', fromPos)
  });
}


// --- Auto-fill when pile runs out: pick a random FACE-DOWN card and continue ---
function basisUsedSet(){
  var used = {};
  var els = document.querySelectorAll('#basis-grid .card[data-index], #basis-grid .backcard[data-index]');
  for (var i=0; i<els.length; i++){
    var v = +els[i].dataset.index;
    if (!isNaN(v)) used[v] = 1;
  }
  return used;
}
function nextUnfilledAnchor(){
  var anchors=[0,1,2,4,8,16,32].filter(function(x){return x<DECK;});
  for (var i=0;i<anchors.length;i++){
    if (readBasisValue(anchors[i])==null) return anchors[i];
  }
  return null;
}
function autoFillFromFaceDownIfPileEmpty(){
  if (!basis || !basis.pile) return false;
  var hasCard = basis.pile.querySelector('.card');
  if (hasCard) return false; // nothing to do

  var pos = nextUnfilledAnchor();
  if (pos==null) return false;

  var used = basisUsedSet();
  var choices = [];
  for (var v=0; v<DECK; v++){
    if (!isFaceUp(v) && !used[v]) choices.push(v);
  }
  if (choices.length==0) return false;

  var pick = choices[Math.floor(Math.random()*choices.length)];
  // Place a face-down placeholder into the anchor
  var cell = basisCellAt(pos);
  if (!cell) return false;
  resetBasisCell(pos);
  cell.appendChild(makeFaceDownPlaceholder(pick));

  // Now complete the span with placeholders where needed
  basisAutoFill();
  return true;
}
function gridIsFullyPlaced(){
  for (var p=0; p<DECK; p++){
    if (readBasisValue(p)==null) return false;
  }
  return true;
}
function fillUntilCompleteFromFaceDown(){
  var changed = false;
  var guard = 0;
  // First, keep picking random face-down values for anchors until all anchors are filled
  while (nextUnfilledAnchor()!=null && guard < DECK+10){
    guard++;
    // if pile has cards, stop; user can keep placing
    if (basis && basis.pile && basis.pile.querySelector('.card')) break;
    if (!autoFillFromFaceDownIfPileEmpty()) break;
    changed = true;
  }
  // With anchors filled (or no more face-down choices), run auto-fill to populate spans
  basisAutoFill();
  // If still any empty positions (shouldn't happen with our placeholders), try a final pass:
  if (!gridIsFullyPlaced()){
    // place placeholders directly for any empty positions using their needed value if anchors known
    var a0 = readBasisValue(0);
    var anchors=[1,2,4,8,16,32].filter(function(x){return x<DECK;});
    var haveAllAnchors = (a0!=null);
    for (var i=0;i<anchors.length;i++){ if (readBasisValue(anchors[i])==null){ haveAllAnchors=false; break; } }
    if (haveAllAnchors){
      // compute required values using existing helper xorFromLower / popcount logic via basisAutoFill's path:
      for (var p=0; p<DECK; p++){
        if (readBasisValue(p)!=null) continue;
        // force a placeholder with its required value by asking basisAutoFill to do it via placeBasisAuto
        // Since basisAutoFill iterates known patterns, call it again
        basisAutoFill();
        if (readBasisValue(p)==null){
          // As a last resort, put a generic placeholder with index p (fallback)
          var cell = basisCellAt(p);
          if (cell) { resetBasisCell(p); cell.appendChild(makeFaceDownPlaceholder(p)); }
        }
      }
    }
  }
  return changed;
}

function readBasisValue(pos){ 
  var cell = basisCellAt(pos); 
  if (!cell) return null;
  // should only be one card, if any, and every card should have data-index
  var card=cell.querySelector('[data-index]'); 
  return card?+card.dataset.index:null;
}

function snapshotLayoutMapping(){ 
  if (!basis) return;
  // Require all anchor basis positions to be filled before declaring complete.
  var anchors=[0,1,2,4,8,16,32].filter(function(x){return x<DECK;});
  for (var i=0;i<anchors.length;i++){
    if (readBasisValue(anchors[i])==null){
      basis.mappingComplete=false; 
      basis.pos2val=null; 
      basis.val2pos=null; 
      return;
    }
  }
  // Build full position/value maps. Any null v means mapping is not ready yet.
  var pos2=[], val2=Array(DECK); 
  for (var p=0;p<DECK;p++){ 
    var v=readBasisValue(p); 
    if (v==null){ 
      basis.mappingComplete=false; 
      basis.pos2val=null; 
      basis.val2pos=null; 
      return;
    }
    pos2[p]=v; 
    val2[v]=p;
  } 
  basis.pos2val=pos2; 
  basis.val2pos=val2; 
  basis.mappingComplete=true;
}

function placeBasisAuto(targetPos, idx){
  var destCell = basisCellAt(targetPos); 
  if (!destCell) return;

  // if the destCell already has the card (idx) in it
  var already = destCell.querySelector('.card[data-index="'+idx+'"]');
  if (already) return; 

  // We are going to place a card here; if the destCell currently has some other card,
  // clear the destCell and send that card to the pile
  resetBasisCell(targetPos)

  // try to find the card (idx) we want to go in destCell
  var card = basis.pile ? basis.pile.querySelector('.card[data-index="'+idx+'"]') : null;
  if (!card) {
    // the card we want to place (idx) was not in the pile, check the basis grid
    card = document.querySelector('#basis-grid .card[data-index="'+idx+'"]');
    if (card){
      var srcCell = card.closest('.cell');
      if (srcCell){
        resetBasisCell(srcCell.getAttribute('data-pos'));
      }
    }
  }
  if (card) {
    card.classList.remove('basis-manual');
    destCell.appendChild(card);
  } else {
    destCell.appendChild(makeFaceDownPlaceholder(idx));
  }
}

function xorFromLower(mask){ 
  var bases=[1,2,4,8,16,32].filter(function(b){return b<DECK;}); 
  var acc=0, have=true; 
  for(var i=0;i<bases.length;i++){ 
    var b=bases[i]; 
    if (mask & b){ 
      var v=readBasisValue(b); 
      if (v==null){ 
        have=false; break;
      } 
      acc ^= v;
    }
  } 
  return have?acc:null;
}

function popcount(x){ var c=0; while(x){ c+=x&1; x>>=1; } return c; }
function basisAutoFill(){ 
  if (!basis.gridL || !basis.gridR) return;
  
  var aV = {}; [0,1,2,4,8,16,32].forEach(function(a) { aV[a] = readBasisValue(a); });
  
  // get list of manually placed cells (skip those in the auto process)
  var Marr = document.querySelectorAll('#basis-grid .card.basis-manual');
  var Mset = {};
  for (var i = 0; i < Marr.length; i++) {
    var cell = Marr[i].closest('.cell');
    if (cell && cell.hasAttribute('data-pos')) { 
      var pos = cell.getAttribute('data-pos');
      Mset[pos] = 1;
    }
  }

  if (!Mset[3]) { if (aV[0]!=null && aV[1]!=null && aV[2]!=null) placeBasisAuto(3, aV[0]^aV[1]^aV[2]); else resetBasisCell(3); }
  if (!Mset[5]) { if (aV[0]!=null && aV[1]!=null && aV[4]!=null) placeBasisAuto(5, aV[0]^aV[1]^aV[4]); else resetBasisCell(5); }
  if (!Mset[6]) { if (aV[0]!=null && aV[2]!=null && aV[4]!=null) placeBasisAuto(6, aV[0]^aV[2]^aV[4]); else resetBasisCell(6); }
  if (!Mset[7]) { if (aV[1]!=null && aV[2]!=null && aV[4]!=null) placeBasisAuto(7, aV[1]^aV[2]^aV[4]); else resetBasisCell(7); }

  if (DECK>8 && aV[8]!=null){ 
    for(var k=1;k<=7 && 8+k<DECK;k++){ 
      if (Mset[8+k]) continue; 
      var vr=xorFromLower(k); if (vr==null){ resetBasisCell(8+k); continue; } 
      var need=(popcount(k)%2==1 && aV[0]!=null)? (aV[0] ^ vr ^ aV[8]) : (vr ^ aV[8]); 
      placeBasisAuto(8+k, need);
    }
  } else { 
    for(var p=9;p<=15 && p<DECK;p++) if (!Mset[p]) resetBasisCell(p);
  }
  
  if (DECK>16 && aV[16]!=null){ 
    for(var k2=1;k2<=15 && 16+k2<DECK;k2++){
      if (Mset[16+k2]) continue;  
      var vr2=xorFromLower(k2); if (vr2==null){ resetBasisCell(16+k2); continue; } 
      var need2=(popcount(k2)%2==1 && aV[0]!=null)? (aV[0] ^ vr2 ^ aV[16]) : (vr2 ^ aV[16]); 
      placeBasisAuto(16+k2, need2);
    }
  } else { 
    for(var p2=17;p2<=31 && p2<DECK;p2++) if (!Mset[p2]) resetBasisCell(p2);
  }
  
  if (DECK>32 && aV[32]!=null){ 
    for(var k3=1;k3<=31 && 32+k3<DECK;k3++){
      if (Mset[32+k3]) continue;  
      var vr3=xorFromLower(k3); if (vr3==null){ resetBasisCell(32+k3); continue; } 
      var need3=(popcount(k3)%2==1 && aV[0]!=null)? (aV[0] ^ vr3 ^ aV[32]) : (vr3 ^ aV[32]); 
      placeBasisAuto(32+k3, need3);
    }
  } else { 
    for(var p3=33;p3<=63 && p3<DECK;p3++) if (!Mset[p3]) resetBasisCell(p3);
  }

  updateAppCounts(); 
  snapshotLayoutMapping();
  clearSuggested();
}

function updateBasisStats(up, quads){ 
  var basisUp = byId('basisUpCount'); if (basisUp) basisUp.textContent = up.length; 
  var basisQ  = byId('basisQuadCount'); if (basisQ) basisQ.textContent = quads;
}

function initBasisTab(){
  basis.pile=byId('basisPile');
  basis.gridL=byId('basis-grid-left');
  basis.gridR=byId('basis-grid-right');
  resetToStandardLayout();
  var startBtn = byId('basisStartNew'); if (startBtn){ startBtn.onclick = function(){ startNewBasis(); }; }
  var sn = byId('basisSuggestNext');
  if (sn){ 
    sn.onclick = basisSuggestNext;
    sn.disabled = false;
  }
  var resetBtn = byId('basisResetLayout'); if (resetBtn){ resetBtn.onclick = resetToStandardLayout; }
}

function refreshBasisEverything(){ 
  if (!basis.mappingComplete){ 
    buildBasisGrid(); refreshBasisPile(); basisAutoFill();
  } else { 
    showPreBasisGrid(); updateAppCounts();
  }
}

// this updates the deck grids
function applyMappingToSelect(){ 
  if (!basis.lockedPos2val) return; 
  for (var p=0; p<DECK; p++){ 
    var val = basis.lockedPos2val[p]; 
    var card = getCardEl(val); 
    if (!card) continue; 
    var cell = card.closest('.cell');
    var parent = (p<HALF) ? gridL : gridR; 
    var idx = (p<HALF) ? p : (p - HALF);
    parent.insertBefore(cell, parent.children[idx] || null);
  }
}

function checkAndLockPositions(){ 
  setBasisMsg();
  snapshotLayoutMapping();
  if (!basis.mappingComplete) return;
  basis.lockedPos2val = basis.pos2val.slice();  // copy
  applyMappingToSelect();
  buildPhiGridIfInit();
  showPreBasisGrid();
  if (basis.pile) basis.pile.innerHTML='';
  sn = byId('basisSuggestNext'); if (sn) sn.disabled = true;
  updateAppCounts();
  setBasisMsg('Basis locked: layout applied to all tabs.');
}

function resetToStandardLayout(){
  var map=[]; 
  for(var i=0;i<DECK;i++) map[i]=i;  // create standard layout
  basis.pos2val = map.slice();  // copy
  basis.val2pos = map.slice();  // copy
  basis.lockedPos2val = map.slice();  // copy
  basis.mappingComplete = true;
  applyMappingToSelect();
  showPreBasisGrid();
  updateAppCounts();
  buildPhiGridIfInit();
  if (basis.pile) basis.pile.innerHTML='';
  setBasisMsg();
}

function makeStaticCard(n){ 
  var cell=document.createElement('div'); cell.className='cell'; 
  var card=document.createElement('div'); card.className='card'; 
  if (isFaceUp(n)) card.classList.add('faceup');
  card.dataset.index=+n; 
  card.appendChild(makeFront(n)); 
  card.appendChild(makeBack()); 
  cell.appendChild(card); 
  return cell;
}

function currentPositionMap(){
  if (basis.mappingComplete) { 
    if (basis.lockedPos2val) return basis.lockedPos2val.slice(); // copy
    if (basis.pos2val) return basis.pos2val.slice(); // copy
  }
  var m=[]; 
  for(var i=0;i<DECK;i++) m[i]=i; // create standard layout
  return m;
}

function showPreBasisGrid(){ 
  if (!basis.gridL || !basis.gridR) return; 
  var map=currentPositionMap(); 
  basis.gridL.innerHTML=''; 
  basis.gridR.innerHTML=''; 
  for(var p=0;p<DECK;p++){ 
    var targetGrid = (p<HALF) ? basis.gridL : basis.gridR; 
    targetGrid.appendChild(makeStaticCard(map[p]));
  }
  byId('basisGridTitle').textContent='Grid (current positions)';
}

function setBasisMsg(t){
  var m = byId('basisMsg'); if (m) m.textContent = t || '';
}

function startNewBasis(){ 
  setBasisMsg(); 
  basis.mappingComplete=false;
  var sn = byId('basisSuggestNext');
  if (sn) {
    sn.onclick = basisSuggestNext;
    sn.disabled = false;
  }
  buildBasisGrid(); 
  refreshBasisPile(); 
  basisAutoFill(); 
}

// Suggestion helpers
function clearSuggested() {
  if (basis.pile){
    var cards = basis.pile.querySelectorAll('.card.suggested');
    for (var i = 0; i < cards.length; i++) {
      cards[i].classList.remove('suggested');
    }
  } 
}

function highlightSuggested(idx,msg) { 
  var el = (idx!=null && basis.pile) ? basis.pile.querySelector('.card[data-index="'+idx+'"]') : null; 
  if (el) {
    clearSuggested();  // clear any old suggested
    el.classList.add('suggested'); 
    setBasisMsg(msg || ('Suggested card: '+idx));
  } else { 
    setBasisMsg(msg || 'No available card to suggest.'); 
  }
}

function pileCandidateArray(){ 
  if (!basis.pile) return [];
  var out = [];
  var cards = basis.pile.querySelectorAll('.card[data-index]');
  for (var i = 0; i < cards.length; i++) {
    var v = +cards[i].dataset.index;
    out.push(v);
  }
  return out;
}

// EXACT auto-fill preview: which indices would actually place now for (next, cand)
function placementDetailsExactAutoFill(pileSet, next, cand){  // ensure candidate is in pileSet
  var aV = {}; [0,1,2,4,8,16,32].forEach(function(a) { aV[a] = readBasisValue(a); });
  aV[next] = cand;   // if next > 1

  var pos2val = (basis.pos2val) ? basis.pos2val : [];
  var mask = (next - 1);

  function needForIndex(k){
    var x = 0; [0,1,2,4,8,16,32].forEach(function(a) { if ((k & a) && aV[a]!=null) x ^= aV[a]; });
    var t = k & mask;  // low
    // hamming weight population count
    t = t - ((t >>> 1) & 0x55555555);
    t = (t & 0x33333333) + ((t >>> 2) & 0x33333333);
    var parity = (((t + (t >>> 4)) & 0x0F) % 2);
    if (parity==1 && aV[0]!=null) x ^= aV[0];
    return x;
  }

  var start = next;
  var end   = Math.min(2*next - 1, 63);
  var indices = [];
  for (var k=start; k<=end; k++){
    if (pos2val && typeof pos2val[k]=='number') continue;
    var req = needForIndex(k);
    if (req < DECK && pileSet[req]) indices.push(k);
  }
  return indices;
}

function basisSuggestNext(){
  if (basis.mappingComplete){ setBasisMsg('Click "Create new basis" first.'); return; }

  // Next unfilled basis among anchors
  var anchors=[0,1,2,4,8,16,32].filter(function(x){return x<DECK;});
  var next=null; for(var i=0;i<anchors.length;i++){ if (readBasisValue(anchors[i])==null){ next=anchors[i]; break; } }
  if (next==null){ setBasisMsg('All basis positions are filled.'); return; }

  // Candidates from pile
  var pile=pileCandidateArray();
  if (pile.length==0){ highlightSuggested(null, null); return; }  // No available

  // Universe of face-up cards
  var Uarr = getSelectedIndicesSorted();
  var Uset = {}; for (var i=0;i<Uarr.length;i++) Uset[Uarr[i]] = 1;

  // Separate logic for picking the best starting (pos 0) card
  if (next == 0) {
    // Count quads containing candidate a: for each c in U, let d=v^c^w, iterate w via U and count unique quads.
    function countQuadsWith(a){
      var cnt=0;
      for (var i=0; i<Uarr.length; i++){
        var b = Uarr[i];
        if (b==a) continue;
        for (var j=i+1; j<Uarr.length; j++){
          var c = Uarr[j];
          if (c==a) continue;
          var d = (a ^ b ^ c);
          if (Uset[d] && d!=a && d>c) cnt++;
        }
      }
      return cnt;
    }
    var best=null, bestScore=-1;
    for (var k=0;k<pile.length;k++){
      var x=pile[k];
      var s=countQuadsWith(x);
      if (s>bestScore || (s==bestScore && x<best)) { bestScore=s; best=x; }
    }
    var why = (best!=null) ? ('Suggested because it participates in ' + bestScore + ' face-up quads — the strongest starting card.') : null;
    highlightSuggested(best, why);
    return;
  }

  // Unified pos 1 scoring
  if (next == 1) {
    // a will always be v0.   looking for quads where a is paired with b
    function countPairQuads(a, b) {
      var cnt = 0;
      for (var i = 0; i < Uarr.length; i++) {
        var c = Uarr[i];
        if (c==a || c==b) continue;
        var d = (a ^ b ^ c);
        if (Uset[d] && d!=a && d!=b && d>c) cnt++;
      }
      return cnt;
    }
    var v0  = readBasisValue(0);
    var best = null, bestScore = -1;
    for (var k = 0; k < pile.length; k++) {
      var x = pile[k];
      var s = countPairQuads(v0, x);
      if (s>bestScore || (s==bestScore && x<best)) { bestScore=s; best=x; }
    }
    var why = (best!=null) ? ('Suggested because together with the card in position 0, it forms ' + bestScore + ' quads — the strongest pair available.') : null;
    highlightSuggested(best, why);
    return;
  }

  // Unified pos > 1 scoring: exact auto-fill preview drives both score and message
  if (next > 1){
    var best = null, bestList = [], bestScore = -1;
    var pileSet = {}; for (var i=0;i<pile.length;i++) pileSet[pile[i]] = 1;
    for (var j = 0; j < pile.length; j++){
      var cand = pile[j];
      var lst  = placementDetailsExactAutoFill(pileSet, next, cand);
      var placed = lst.length;
      if (placed > bestScore || (placed==bestScore && cand < best)){
        bestScore = placed; best = cand; bestList = lst;
      }
    }
    var why = (best!=null) ? ('would place ' + bestScore + ' cards: [' + bestList.join(', ') + ']') : null;
    highlightSuggested(best, why);
    return;
  }
}

// this sets up so that the previous basis msg is cleared on any document click
var _basisMsgClearScheduled = false;
function scheduleclearBasisMsgOnNextClick(){
  if (_basisMsgClearScheduled) return;
  _basisMsgClearScheduled = true;
  var handler = function(){
    setBasisMsg();
    _basisMsgClearScheduled = false;
    document.removeEventListener('click', handler, true);
  };
  document.addEventListener('click', handler, true);
}

//==Phi Map==
var phi={ gridL:null, gridR:null, part:null, initialized:false, flowActive:false, selA:null, selB:null, lastPhi:null, quadsBefore:0, quadsAfter:0 };
function buildPhiGridIfInit(){ if (phi.initialized) buildPhiGrid(); }
function makePhiCard(n){
  var cell=document.createElement('div'); cell.className='cell phiCell'; var card=document.createElement('div'); 
  card.className='card'+(isFaceUp(n)?' faceup':''); card.dataset.index=n; 
  card.appendChild(makeFront(n)); 
  card.appendChild(makeBack()); 
  cell.appendChild(card); return cell; }
function updatePhiQuadsDisplay(){ 
  var beforeEl = byId('phiQuadBefore'); if (beforeEl) beforeEl.textContent = phi.quadsBefore || 0; 
  var afterEl = byId('phiQuadAfter'); if (afterEl) afterEl.textContent = phi.lastPhi ? (phi.quadsAfter || 0) : '';
}
// Helper: fire the dropdown change event so the purple/gold updates immediately
function triggerPhiDropdown(){
  const dd = document.querySelector('#phiPartition');
  if (dd){
    dd.dispatchEvent(new Event('change', { bubbles: true }));
  }
}
function buildPhiGrid(){ 
  if (!phi.gridL || !phi.gridR) return; 
  if (phi._building) return; 
  phi._building = true;
  try {
    phi.gridL.innerHTML=''; 
    phi.gridR.innerHTML=''; 
    if (!phi.lastPhi && !phi.flowActive){ 
      phi.quadsBefore = computeQuadsBasic(getSelectedIndicesSorted());
    }
    var map=currentPositionMap(); 
    phi.part = phi.part || (function(){ var sel = byId('phiPartition'); 
      var mode; 
      if (DECK==16){ 
        mode='rowsdbl'; 
        if (sel) sel.value='rowsdbl';
      } else { 
        mode = sel ? sel.value : 'lr';
      } 
      return buildPartition(mode);
    })();
    for(var p=0;p<DECK;p++){ 
      var v=map[p]; 
      var cell=makePhiCard(v); 
      cell.dataset.pos=String(p); 
      if (phi.part && phi.part[p]=='A'){ 
        cell.classList.add('phiA');
      } else if (phi.part && phi.part[p]=='B'){
        cell.classList.add('phiB');
      }
      var targetGrid = (p<HALF) ? phi.gridL : phi.gridR; 
      targetGrid.appendChild(cell);
    }
    updateAppCounts(); 
    enhancePhiGrid(); 
    reapplySelectedAB(); 
    updateAHighlights();
  } finally {
    phi._building = false;
  }
}
function initPhiTab(){ phi.gridL = byId('phi-grid-left'); phi.gridR = byId('phi-grid-right'); updatePartitionDisables(); var sel = byId('phiPartition'); var mode; if (DECK==16){ mode='rowsdbl'; if (sel) sel.value='rowsdbl'; } else { mode = sel ? sel.value : 'lr'; } phi.part = buildPartition(mode); buildPhiGrid(); if (sel){ sel.addEventListener('change', function(){ phi.part = buildPartition(sel.value); buildPhiGrid(); resetFlowUI(); clearPhiUndo(); }); } byId('phiStart').onclick=startFlow; byId('phiApply').onclick=applyFlow; byId('phiClearSel').onclick=function(){ resetFlowUI(); buildPhiGrid(); }; byId('phiUndo').onclick=undoPhiMap; phi.initialized = true; }
function reapplySelectedAB(){ if (phi.selA==null && phi.selB==null) return; function mark(index, cls){ if (index==null) return; var el=document.querySelector('#phi-grid-left .card[data-index="'+index+'"], #phi-grid-right .card[data-index="'+index+'"]'); if (el){ var cell=el.closest('.cell'); if (cell) cell.classList.add(cls); } } mark(phi.selB,'phiSelectedB'); mark(phi.selA,'phiSelectedA'); }
function updatePartitionDisables(){ var sel = byId('phiPartition'); if (!sel) return; for(var i=0;i<sel.options.length;i++) sel.options[i].disabled=false; if (DECK==32){ var optTB=sel.querySelector('option[value="tb"]'); if (optTB) optTB.disabled=true; if (sel.value=='tb') sel.value='lr'; } if (DECK==16){ var optTB2=sel.querySelector('option[value="tb"]'); var optLR=sel.querySelector('option[value="lr"]'); if (optTB2) optTB2.disabled=true; if (optLR) optLR.disabled=true; if (sel.value=='tb' || sel.value=='lr') sel.value='rowsdbl'; } }
function posRC(p){ 
  var cols=4; 
  var rowsPerSide=(DECK==64?8:4); 
  var local=(DECK==16? p : (p<HALF? p : p-HALF)); 
  var row=Math.floor(local/cols); 
  var col=local%cols; 
  return { row:row, col:col, rowsPerSide:rowsPerSide, side:(p<HALF?'L':'R') };
}

function buildPartition(mode){ 
  var part=Array(DECK).fill('B');  // A or B, default B 
  for(var p=0;p<DECK;p++){ 
    var rc=posRC(p);
    var inA=false; 
    if (mode=='lr'){ inA=(rc.side=='L');
    } else if (mode=='tb'){ inA=(rc.row < rc.rowsPerSide/2);
    } else if (mode=='rowsdbl'){ inA=(Math.floor(rc.row/2)%2==0);
    } else if (mode=='colsdbl'){ inA=(Math.floor(rc.col/2)%2==0);
    } else if (mode=='rowsAlt'){ inA=(rc.row%2==0);
    } else if (mode=='colsAlt'){ inA=(rc.col%2==0);
    }
    if (inA) part[p]='A';
  }
  return part;
}

function enhancePhiGrid(){ 
  var map=currentPositionMap(); 
  var cellsL=byId('phi-grid-left').children; 
  var cellsR=byId('phi-grid-right').children; 
  function attach(cell,p){ 
    var v=(p<map.length)? map[p]:null; 
    var cardEl=cell.querySelector('.card'); 
    var up=cardEl && cardEl.classList.contains('faceup'); 
    cell.onclick=function(){ 
      if (!phi.part) return; 
      var isA=(phi.part[p]=='A'); 
      var isB=!isA; 
      if (phi.flowActive){ 
        if (phi.selB==null){ 
          if (isB && up){ 
            phi.selB=v; 
            cell.classList.add('phiSelectedB'); 
            setPhiInfo('b = '+v+' ('+pad6(v)+'). Now pick a (face-down) from gold A.'); 
            updateAHighlights();
          } else { 
            setPhiInfo('b must be FACE-UP in purple B.');
          }
        } else if (phi.selA==null){ 
          var up2=cardEl && cardEl.classList.contains('faceup'); 
          if (isA && !up2){ 
            phi.selA=v; 
            cell.classList.add('phiSelectedA'); 
            byId('phiApply').disabled=false; 
            setPhiInfo('a = '+v+' ('+pad6(v)+'). Click Apply.'); 
            updateAHighlights();
          } else { 
            setPhiInfo('a must be FACE-DOWN in gold A.');
          }
        }
      }
    };
  }
  for(var i=0;i<cellsL.length;i++) attach(cellsL[i], i);
  for(var j=0;j<cellsR.length;j++) attach(cellsR[j], HALF+j);
}

function setPhiInfo(msg){ var el = byId('phiInfo'); if (el){ el.innerHTML=msg; } }
function updateAHighlights(){ 
  clearATargetShadows(); 
  if (phi.selA==null || phi.selB==null) return; 
  var mask=(DECK==64?63:(DECK==32?31:15)); 
  var map=currentPositionMap(); 
  for(var p=0;p<DECK;p++){ 
    if (!phi.part || phi.part[p]!="B") continue; var v=map[p]; 
    var phiCell = (p<HALF) ? byId('phi-grid-left').children[p] : byId('phi-grid-right').children[p-HALF]; if (!phiCell) continue; 
    var phiCard = phiCell.querySelector('.card'); 
    var isUp = !!(phiCard && phiCard.classList.contains('faceup')); 
    if (!isUp) continue; 
    var t=(v ^ phi.selA ^ phi.selB) & mask; 
    var targetCard = document.querySelector('#phi-grid-left .card[data-index="'+t+'"], #phi-grid-right .card[data-index="'+t+'"]'); 
    if (targetCard){ targetCard.classList.add('a-shadow'); }
  }
}
function clearATargetShadows(){ var cards=document.querySelectorAll('#phi-grid-left .card, #phi-grid-right .card'); for(var i=0;i<cards.length;i++){ cards[i].classList.remove('a-shadow'); } }
function startFlow(){ 
  phi.flowActive=true; 
  phi.selA=null; 
  phi.selB=null; 
  byId('phiApply').disabled=true; 
  updateAppCounts(); 
  setPhiInfo('Flow active: pick b (face-up, purple B), then a (face-down, gold A).'); 
  updateAHighlights();
}
function resetFlowUI(){ phi.flowActive=false; phi.selA=null; phi.selB=null; byId('phiApply').disabled=true; clearATargetShadows(); clearSelections(); setPhiInfo('Pick a face-up card for <b>b</b> from a purple (B) zone, then a face-down card for <b>a</b> from a gold (A) zone.'); }
function clearSelections(){ var cells=document.querySelectorAll('#phi-grid-left .cell, #phi-grid-right .cell'); for(var i=0;i<cells.length;i++){ cells[i].classList.remove('phiSelectedA','phiSelectedB'); } }
function clearPhiUndo(){ phi.lastPhi=null; var u=byId('phiUndo'); if (u) u.disabled=true; }
function updateUndoState(){ var u=byId('phiUndo'); if (u) u.disabled=!phi.lastPhi; }
function applyFlow(){
  if (phi.selA==null || phi.selB==null) return;
  var a=phi.selA, b=phi.selB;
  var mask=(DECK==64?63:(DECK==32?31:15));
  var swaps=[];
  var map=currentPositionMap();
  for(var p=0;p<DECK;p++){
    if (phi.part[p]=='B'){
      var v=map[p];
      if (isFaceUp(v)){
        var t=(v ^ a ^ b) & mask;
        if (!isFaceUp(t)){
          setFaceUp(v,false);
          setFaceUp(t,true);
          swaps.push({from:v,to:t});
        }
      }
    }
  }
  phi.lastPhi={a:a,b:b,swaps:swaps,deck:DECK};
  updateUndoState();
  updateAppCounts(true);  // after
  setPhiInfo('<b>Applied φ-map</b> with <b>b='+b+'</b>, <b>a='+a+'</b>.');
  resetFlowUI();
  buildPhiGrid();
}

function undoPhiMap(){ 
  if (!phi.lastPhi) return; 
  if (phi.lastPhi.deck!=DECK){ 
    setPhiInfo('Cannot undo: deck size changed.'); 
    clearPhiUndo(); 
    return;
  }
  var s=phi.lastPhi.swaps || []; 
  for(var i=0;i<s.length;i++){ 
    var f=s[i].from, t=s[i].to; 
    if (isFaceUp(t)) setFaceUp(t,false); 
    if (!isFaceUp(f)) setFaceUp(f,true);
  }
  updateAppCounts(true);  // after
  setPhiInfo('Undid last φ-map.'); 
  clearPhiUndo(); 
  buildPhiGrid();
}

//==Find Quads==
var find = {
  initialized:false,
  gridL:null, gridR:null,
  selected:[],
  found:[],
  foundSet:{},
  cap:20
};
function buildFindGridIfInit(){ if (find.initialized) buildFindGrid(); }
function initFindTab(){
  find.gridL = byId('find-grid-left');
  find.gridR = byId('find-grid-right');
  byId('findClearSel').onclick = clearFindSelection;
  byId('findResetList').onclick = resetFoundList;
  byId('findHint').onclick = hintOneQuad;
  find.initialized = true;
  buildFindGrid();
  updateFindCounts();
}
function buildFindGrid(){
  if (!find.gridL || !find.gridR) return;
  find.gridL.innerHTML=''; 
  find.gridR.innerHTML='';
  var map = currentPositionMap();
  for(var p=0;p<DECK;p++){
    var v=map[p];
    /* tbd !!! potential makeCard or makeCell */
    var cell=document.createElement('div'); 
    cell.className='cell';
    var card=document.createElement('div'); 
    card.className='card';
    card.dataset.index=v;
    if (isFaceUp(v)) card.classList.add('faceup');
    card.appendChild(makeFront(v));
    card.appendChild(makeBack());
    cell.appendChild(card);
    var target=(p<HALF)?find.gridL:find.gridR;
    target.appendChild(cell);

    (function(cardEl, value){
      cardEl.addEventListener('click', function(){
        var up = cardEl.classList.contains('faceup');
        if (!up) { setFindMsg('Select only face-up cards.'); return; }
        toggleFindSelection(cardEl, value);
      });
    })(card, v);
  }

  byId('findGridTitle').textContent = 'Find Quads Grid';
  setFindMsg('Pick four face-up cards to test for a quad.');
  syncFindSelectedClass();
  renderFoundList();
  updateFindCounts();
}
function setFindMsg(msg){ var el = byId('findMsg'); if (el) el.textContent=msg || ''; }
function toggleFindSelection(cardEl, value){
  var idx = find.selected.indexOf(value);
  if (idx>=0){
    find.selected.splice(idx,1);
    cardEl.classList.remove('selected');
    updateFindCounts();
    return;
  }
  if (find.selected.length>=4){
    setFindMsg('You already have 4 selected. Clear or deselect one.');
    return;
  }
  find.selected.push(value);
  cardEl.classList.add('selected');
  if (find.selected.length==4){
    checkAndStoreQuad(find.selected.slice());
  }
  updateFindCounts();
}

function clearFindSelection(){
  find.selected.length=0;
  syncFindSelectedClass();
  updateFindCounts();
  setFindMsg('Selection cleared.');
}

function getFindGridCardEl(n){ 
  return ((n!=null) && (n>=0)) ? document.querySelector('#find-grid .card[data-index="'+n+'"]') : null;
}

function syncFindSelectedClass(){
  // get the set of cards that are selected
  var cards = document.querySelectorAll('#find-grid .card.selected');
  for(var i=0; i<cards.length; i++) cards[i].classList.remove('selected');
  for(var j=0; j<find.selected.length; j++){
    var v=find.selected[j];
    var el=getFindGridCardEl(v); if (el) el.classList.add('selected');
  }
}

function keyForQuad(arr){ return arr.slice().sort(function(a,b){return a-b;}).join(','); }

function isQuad(arr){
  if (arr.length!=4) return false;
  var mask=(DECK==64?63:(DECK==32?31:15));
  var a=arr[0]&mask, b=arr[1]&mask, c=arr[2]&mask, d=arr[3]&mask;
  return ((a^b^c^d)==0);
}

function checkAndStoreQuad(sel4){
  for(var i=0;i<sel4.length;i++){ if (!isFaceUp(sel4[i])){ setFindMsg('All four must be face-up.'); return finishSelection(false); } }
  if (!isQuad(sel4)){
    setFindMsg('Not a quad. Try again.');
    return finishSelection(false);
  }
  var key = keyForQuad(sel4);
  if (find.foundSet[key]){
    setFindMsg('You already found that quad.');
    return finishSelection(true);
  }
  if (find.found.length >= find.cap){
    setFindMsg('List full (' + find.cap + '). Reset to add more.');
    return finishSelection(true);
  }
  var sorted=sel4.slice().sort(function(a,b){return a-b;});
  find.found.push(sorted);
  find.foundSet[key]=1;
  renderFoundList();
  updateFindCounts();
  setFindMsg('✔ Quad recorded!');
  return finishSelection(true);
}

function finishSelection(clearIt){
  if (clearIt){ find.selected.length=0; }
  syncFindSelectedClass();
}

function renderFoundList(){
  var wrap = byId('foundQuadsWrap');
  if (!wrap) return;
  wrap.innerHTML='';
  for(var i=0; i<find.found.length; i++){
    var q=find.found[i];
    var fq=document.createElement('div'); 
    fq.className='found-quad';
    for(var j=0;j<q.length;j++) fq.appendChild(makeMiniCard(q[j]));
    wrap.appendChild(fq);
  }
}

function clearFindHints(){
  var cards = document.querySelectorAll('#find-grid .card.hint');
  for(var i=0;i<cards.length;i++) cards[i].classList.remove('hint');
}

function hintOneQuad(){
  // Clear any previous yellow hint rings
  clearFindHints();

  // Universe = all face-up cards in the main state
  var Uarr = getSelectedIndicesSorted();  // e.g., [6,7,10,11,14,15]
  var n = Uarr.length;
  if (n<4){
    setFindMsg('Not enough face-up cards for a hint.');
    return;
  }
  // Quick lookup for "is this face-up?"
  var Uset = {}; for (var i=0; i<n; i++) Uset[Uarr[i]] = 1;

  // Selected (blue outline) cards in the Find tab
  var S = (find && find.selected) ? find.selected.slice() : [];
  // Ensure they’re all face-up
  S = S.filter(function(x){ return Uset[x]; });

  // Helpers
  function alreadyFound(q){ return (find && find.foundSet && find.foundSet[keyForQuad(q)]); }

  function hintCards(Q){
    for (var k=0;k<4;k++){
      var v = Q[k];
      var el = getFindGridCardEl(v);
      if (el) el.classList.add('hint');
    }
    setTimeout(clearFindHints, 2500);
  }

  //==Case 0 selected: fall back to ANY new quad among face-up cards==
  if (S.length==0){
    for (var a=0; a<n; a++){
      for (var b=a+1; b<n; b++){
        for (var c=b+1; c<n; c++){
          for (var d=c+1; d<n; d++){
            var quad = [Uarr[a], Uarr[b], Uarr[c], Uarr[d]];
            if (!isQuad(quad)) continue;
            if (alreadyFound(quad)) continue;
            hintCards(quad);
            setFindMsg('Hint: these four form a quad.');
            return;
          }
        }
      }
    }
    setFindMsg('No new quad to hint from current face-up cards.');
    return;
  }

  //==Case 3+ selected: try every 3-subset; the 4th is a^b^c==
  if (S.length >= 3){
    for (var i1=0;i1<S.length;i1++){
      for (var j1=i1+1;j1<S.length;j1++){
        for (var k1=j1+1;k1<S.length;k1++){
          var a3=S[i1], b3=S[j1], c3=S[k1];
          var d3=(a3^b3^c3);
          if (!Uset[d3]) continue;  // not faceup
          var quad3=[a3,b3,c3,d3];
          if (!isQuad(quad3)) continue;
          if (alreadyFound(quad3)) continue;
          hintCards(quad3);
          setFindMsg('Hint: completed a quad from your selected cards.');
          return;
        }
      }
    }
    setFindMsg('No new quad uses those highlighted cards.');
    return;
  }

  //==Case 2 selected: scan any face-up c to complete a quad==
  if (S.length==2){
    var a2=S[0], b2=S[1];
    for (var i2=0;i2<n;i2++){
      var c2=Uarr[i2];
      if (c2==a2 || c2==b2) continue;
      var d2=(a2^b2^c2);
      if (!Uset[d2]) continue;  // not faceup
      var quad2=[a2,b2,c2,d2];
      if (!isQuad(quad2)) continue;
      if (alreadyFound(quad2)) continue;
      hintCards(quad2);
      setFindMsg('Hint: found a quad that uses your 2 highlighted cards.');
      return;
    }
    setFindMsg('No new quad uses those two highlighted cards.');
    return;
  }

  //==Case 1 selected: scan face-up pairs (b,c) to complete a quad==
  if (S.length==1){
    var a1=S[0];
    for (var i3=0;i3<n;i3++){
      var b1=Uarr[i3];
      if (b1==a1) continue;
      for (var j3=i3+1;j3<n;j3++){
        var c1=Uarr[j3];
        if (c1==a1) continue;
        var d1=(a1^b1^c1);
        if (!Uset[d1]) continue;  // not faceup
        var quad1=[a1,b1,c1,d1];
        if (!isQuad(quad1)) continue;
        if (alreadyFound(quad1)) continue;
        hintCards(quad1);
        setFindMsg('Hint: found a quad that uses your highlighted card.');
        return;
      }
    }

    setFindMsg('No new quad uses highlighted card(s).');
    return;
  }
}

function resetFoundList(){
  if (!find) return;
  find.found.length=0;
  find.foundSet={};
  renderFoundList();
  updateFindCounts();
  setFindMsg('Found list reset.');
}

function updateFindCounts(quads){
  var totalEl = byId('findTotalQuads');
  var foundEl = byId('findFoundCount');
  if (!totalEl && !foundEl) return;
  if (quads == undefined) quads = computeQuadsBasic(getSelectedIndicesSorted());
  find.cap = Math.min(20, quads);
  if (totalEl) totalEl.textContent = quads;
  if (foundEl){ 
    foundEl.textContent = find.found.length + ' / ' + find.cap;
  }
}

// ---- Tiny sanity checks ----
(function(){ try{
  console.assert(computeQuadsBasic([])==0, '0 quads for empty');
  console.assert(computeQuadsBasic([0,1,2,3])==1, 'one quad in 0,1,2,3');
} catch(e){ console.warn('Sanity tests failed', e); } })();
</script>
</body>
</html>
