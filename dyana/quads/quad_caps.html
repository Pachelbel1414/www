<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Grid Cards — New Basis (Drag, Odd-Sum Rule, Quad-Safe)</title>
<style>
  :root{
    --bg:#fafafa; --ink:#111; --muted:#6b7280; --border:#e5e7eb; --card:#fff;
    --cols: 8;
    --gap: 8px;
    --cellW: 140px;
    --cellH: 88px;  /* 16:10 => H = W * 0.625 */
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .app{max-width:1200px;margin:0 auto;padding:16px}
  h1{margin:0 0 8px 0;font-size:20px}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin:10px 0}
  label{font-weight:600}
  select{padding:6px 8px;border:1px solid var(--border);border-radius:8px;background:#fff}
  .toggle{display:inline-flex;align-items:center;gap:8px;font-weight:700;background:#eef2ff;border:1px solid #e0e7ff;border-radius:999px;padding:6px 10px}
  button{padding:6px 10px;border:1px solid var(--border);border-radius:8px;background:#fff;cursor:pointer;font-weight:600}
  button:hover{background:#f3f4f6}
  .grid{
    display:grid;
    gap:var(--gap);
    grid-template-columns: repeat(var(--cols), var(--cellW));
    grid-auto-rows: var(--cellH);
    justify-content:center;
  }
  .cell{
    position:relative;
    width:var(--cellW);
    height:var(--cellH);
    border-radius:10px;
    border:2px solid rgba(255,255,255,0.9);
    display:flex;
    justify-content:center;
    align-items:center;
    overflow:hidden;
  }
  .card{
    background:#d1d5db;
    border:none;
    border-radius:8px;
    width:calc(var(--cellW) - 12px);
    height:calc(var(--cellH) - 12px);
    display:flex;
    justify-content:center;
    align-items:center;
    font-weight:700;
    font-family:ui-monospace,Menlo,Consolas,monospace;
    font-size:clamp(12px, calc(var(--cellH) * 0.35), 28px);
    box-shadow:0 1px 2px rgba(0,0,0,.08);
    cursor:pointer;
    user-select:none;
    color:transparent;
  }
  .faceup{ background:#ffffff; color:#111; }
  .facedown{ background:#d1d5db; color:transparent; }
  .locked{ background:#d1d5db; color:#ef4444; cursor:default; }

  /* Pile + basis targets */
  #pileWrap{ display:none; margin:8px 0; }
  .pile{ display:flex;flex-wrap:wrap;gap:8px;padding:10px;border:1px dashed #cbd5e1;border-radius:10px;background:#fff; }
  .draggable{
    width:calc(var(--cellW) - 12px);
    height:calc(var(--cellH) - 12px);
    border-radius:8px;
    border:1px solid var(--border);
    display:flex;justify-content:center;align-items:center;
    background:#fff;
    cursor:grab;
    font-weight:800;
    font-family:ui-monospace,Menlo,Consolas,monospace;
  }
  .basisTarget{ outline:3px dashed #ef4444; outline-offset:-6px; }
  .basisChip{
    position:absolute;top:6px;left:6px;
    background:#fff;border:1px solid var(--border);border-radius:6px;
    font: 700 12px ui-monospace,Menlo,Consolas,monospace;
    padding:2px 6px;
  }
  .chipRem{ margin-left:6px; font:700 12px system-ui; cursor:pointer; color:#ef4444; }
.toggle.disabled{opacity:.5; pointer-events:none; cursor:not-allowed}

  .pile-disabled{ opacity:0.35; filter:grayscale(100%); cursor:not-allowed !important; }

  /* Analyze mode target highlight */
  .analyzeTarget{
    outline: 3px solid #3b82f6;
    box-shadow: 0 0 0 3px rgba(59,130,246,0.25);
  }


  .controls-row{display:flex;align-items:center;gap:8px;flex-wrap:wrap;}

  /* Top toolbar layout */
  .toolbar{
    position: static;
    display: flex;
    flex-wrap: wrap;
    gap: 16px;
    align-items: center;
    justify-content: center;
    margin: 8px auto 10px;
    max-width: 1200px;
  }
  .toolbar .group{
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
  }
  .toolbar .toggle{ display:inline-flex; align-items:center; gap:6px; }
  .toolbar .inline{ display:inline-flex; align-items:center; gap:4px; }
  .toolbar .right{ margin-left: auto; }
  #grid{ margin-top: 6px; }

</style>
</head>
<body>
  <div class="app" id="appRoot">
    <h1>Grid Cards — New Basis</h1>
    <div id="controls"><div id="topControls" class="toolbar">
  <!-- Group 1: deck & quick toggles -->
  <div class="group">
    <label>Deck size:
      <select id="deck">
        <option value="16">16</option>
        <option value="32">32</option>
        <option value="64" selected>64</option>
        <option value="128">128</option>
        <option value="256">256</option>
        <option value="512">512</option>
      </select>
    </label>

    <label class="toggle">
      <input type="checkbox" id="binaryToggle">
      <span>Show binary numbers</span>
    </label>

    <button id="clearCardsBtn">Clear Current Cards</button>
    <button id="revealRedBtn">Turn Red Locations Face Up</button>
  </div><span id="posCount" style="display:none">0</span></div>

  <!-- Group 2: basis actions -->
  <div class="group">
    <button id="newBasisBtn">Create New Basis</button>
    <button id="randomBasisBtn">Random Basis</button>
    <button id="returnStdBtn">Return to Standard Locations</button>
  </div>

  <!-- Group 3: analyze & bases listing -->
  <div class="group">
    <button id="analyzeBtn" title="Click to toggle Analyze mode">Analyze Card</button>
    <button id="countBasesBtn" title="Count the valid bases">Count Bases</button>
    <label class="inline">
      <span>List first</span>
      <input id="listNInput" type="number" min="1" value="50" style="width:64px;">
    </label>
    <button id="listBasesOnScreenBtn">List on screen</button>
    <button id="listBasesCsvBtn">Export CSV</button>
  </div>

  <!-- Edit toggle on the right -->
  <label class="toggle right">
    <input type="checkbox" id="editToggle" checked>
    <span>Allow adding/removing cards</span>
  </label>

  <!-- Analyze hint (shown only in analyze mode) -->
  <span id="analyzeHint" class="muted" style="display:none;">Analyze: click a face-up card on the grid.</span>
</div>

    <div id="pileWrap">
      <div class="muted" style="margin:6px 0;font-weight:700">
        Drag face‑up cards into <span style="color:#ef4444">red</span> basis cells (0 and powers of 2). You can drag a placed chip back to the pile (×).
      </div>
      <div id="pile" class="pile" ondragover="event.preventDefault()"></div>
    </div>

    <div id="grid" class="grid"></div>
<div id="basesPanel" style="margin-top:8px;display:none;">
  <div class="pill" style="display:inline-block;border:1px solid var(--border);border-radius:999px;padding:6px 10px;margin-bottom:8px;">
    <strong>Possible Bases</strong>
  </div>
  <div id="basesMeta" class="muted"></div>
  <div id="basesResults" class="muted">Results will appear here.</div>
</div>

    <div id="analysisPanel" style="margin-top:8px;display:none;">
      <div class="pill" style="display:inline-block;border:1px solid var(--border);border-radius:999px;padding:6px 10px;margin-bottom:8px;">
        <strong>Analysis</strong>
      </div>
      <div id="analysisResults" class="muted">Analysis results will appear here.</div>
    </div>

  </div>

<script>
(function(){
  const deckSel = document.getElementById('deck');
  const grid = document.getElementById('grid');
  const posCount = document.getElementById('posCount');
  const binaryToggle = document.getElementById('binaryToggle');
  const appRoot = document.getElementById('appRoot');
  const controls = document.getElementById('controls');
  const newBasisBtn = document.getElementById('newBasisBtn');
  const returnStdBtn = document.getElementById('returnStdBtn');
  const pileWrap = document.getElementById('pileWrap');
  const pile = document.getElementById('pile');

  let DECK = parseInt(deckSel.value, 10);
  let showBinary = false;

  function padN(n,b){ let s=n.toString(2); while(s.length<b) s='0'+s; return s; }
  function bitsForDeck(d){ return (d===16?4:(d===32?5:(d===64?6:(d===128?7:(d===256?8:9))))); }
  function labelFor(n){ return showBinary ? padN(n, bitsForDeck(DECK)) : String(n); }
  function popcount(x){ x = x>>>0; let c=0; while(x){ x&=x-1; c++; } return c; }
  function colorForWeight(w){
    if(w<=1) return {fill:"#fecaca"};
    if(w<=3) return {fill:"#fed7aa"};
    if(w<=5) return {fill:"#fef08a"};
    if(w<=7) return {fill:"#bbf7d0"};
    if(w<=9) return {fill:"#bfdbfe"};
    return {fill:"#e9d5ff"};
  }
  function columnsForDeck(deck){
    if(deck===16) return 4;
    if(deck===32) return 8;
    if(deck===64) return 8;
    if(deck===128) return 16;
    if(deck===256) return 16;
    if(deck===512) return 32;
    return 8;
  }
  function applyColumns(){
    document.documentElement.style.setProperty('--cols', columnsForDeck(DECK));
  }
  function layoutToFit(){
    // Adjust only spacing for 512 (cards/cells stay same size)
    try{
      const baseGap = 8; // matches :root --gap
      const gapVal = baseGap * 0.2; // much tighter spacing for all decks (80% reduction)
      document.documentElement.style.setProperty('--gap', gapVal + 'px');
    }catch(_){}

    const cols = columnsForDeck(DECK);
    const rows = Math.ceil(DECK / cols);
    const appStyles = getComputedStyle(appRoot);
    const appPadH = parseFloat(appStyles.paddingLeft) + parseFloat(appStyles.paddingRight);
    const gridWidth = appRoot.clientWidth - appPadH;
    const gap = parseFloat(getComputedStyle(grid).gap || '8');
    const maxW_fromWidth = (gridWidth - gap * (cols - 1)) / cols;
    const viewportH = window.innerHeight;
    const controlsH = controls.getBoundingClientRect().height + (pileWrap.style.display!=='none' ? pileWrap.getBoundingClientRect().height : 0);
    const appPadV = parseFloat(appStyles.paddingTop) + parseFloat(appStyles.paddingBottom);
    const availableH = viewportH - controlsH - appPadV - 16;
    const maxH_perRow = (availableH - gap * (rows - 1)) / rows;
    const maxW_fromHeight = maxH_perRow / 0.625;
    let cellW = Math.max(60, Math.min(maxW_fromWidth, maxW_fromHeight));
    // 512: keep cell size; adjust spacing via --gap below
const cellH = cellW * 0.625;
    document.documentElement.style.setProperty('--cellW', cellW + 'px');
    document.documentElement.style.setProperty('--cellH', cellH + 'px');
  }

  // ----- State -----
  // Each cell/location: {pos, value, faceup, locked, card, cell}
  let cells = [];
  let faceUpPositions = new Set(); // positions that are face up
  function columns(){ return columnsForDeck(DECK); }

  let editEnabled = true; // when false, user clicks won't change face-up set

  function setEditEnabled(on){
editEnabled = !!on;
    updateClearButtonState();
  
  updateButtonStates();
}

  function updateClearButtonState(){
    const btn = document.getElementById('clearCardsBtn');
    if(!btn) return;
    const disabled = (!editEnabled) || (faceUpPositions.size === 0);
    btn.disabled = disabled;
    btn.style.opacity = disabled ? '0.5' : '1';
    btn.style.cursor = disabled ? 'not-allowed' : 'pointer';
  }

  function updateButtonStates(){
  const rr = document.getElementById('revealRedBtn');
  if(rr){
      const canReveal = editEnabled && (faceUpPositions.size === 0);
  rr.disabled = !canReveal;
  rr.style.opacity = canReveal ? '1' : '0.5';
  rr.style.cursor = canReveal ? 'pointer' : 'not-allowed';

    }
  }


  function makeCell(pos){
    const w = popcount(pos);
    const {fill} = colorForWeight(w);
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.style.background = fill;
    cell.dataset.pos = String(pos);

    const card = document.createElement('div');
    card.className = 'card facedown';
    card.addEventListener('click', () => toggleCard(pos));
    cell.appendChild(card);

    const c = {pos, value: pos, faceup:false, locked:false, card, cell};
    cells[pos]=c;
    return cell;
  }

  function rebuild(){
    cells = [];
    faceUpPositions.clear();
    grid.innerHTML='';
    posCount.textContent=String(DECK);
    applyColumns();
    for(let p=0;p<DECK;p++) grid.appendChild(makeCell(p));
    layoutToFit();
    updateLocks();
    updateClearButtonState();
    updateButtonStates();
  }

  function toggleCard(pos){
    // If we're in Analyze mode, use this click to analyze instead of editing
    try{
      if(typeof analyzeMode !== 'undefined' && analyzeMode){
        const cA = cells[pos];
        const analysisPanel = document.getElementById('analysisPanel');
        const analysisResults = document.getElementById('analysisResults');
        // Require face-up for analysis
        if(!cA || !cA.faceup){
          if(analysisResults) analysisResults.textContent = 'Please click a face‑up card.';
          return;
        }
        // Clear previous highlights and highlight target
        document.querySelectorAll('.analyzeTarget').forEach(el => el.classList.remove('analyzeTarget'));
        (cA.card || cA.cell).classList.add('analyzeTarget');
        // Ensure panel visible and update message immediately
        if(analysisPanel) analysisPanel.style.display = 'block';
        if(analysisResults){
          analysisResults.innerHTML = '<div><strong>Target:</strong> ' + labelFor(cA.value) + '</div><div class="muted">Finding odd XOR representations…</div>';
        }
        // Compute results
        lastAnalyzePos = pos;
        if(typeof analyzeOddXorRepresentations === 'function') analyzeOddXorRepresentations(pos);
        try{ analysisPanel?.scrollIntoView({behavior:'smooth', block:'nearest'}); }catch(_){}
        return;
      }
    }catch(_){ /* ignore */ }
    if(basisMode) return;
    if(!editEnabled) return;
    const c = cells[pos];
    if(!c) return;
    if(!c.faceup){
      if(c.locked) return;
      c.faceup=true; faceUpPositions.add(pos);
      c.card.className='card faceup'; c.card.textContent=labelFor(c.value);
    }else{
      c.faceup=false; faceUpPositions.delete(pos);
      c.card.className='card facedown'; c.card.textContent='';
    }
    updateLocks();
    updateClearButtonState();
    updateButtonStates();
  }

  function xor3Counts(values){
    const out=new Map();
    for(let i=0;i<values.length;i++)
      for(let j=i+1;j<values.length;j++)
        for(let k=j+1;k<values.length;k++){
          const v=values[i]^values[j]^values[k];
          out.set(v,(out.get(v)||0)+1);
        }
    return out;
  }

  function updateLocks(){
    const values = Array.from(faceUpPositions).map(p => cells[p].value);
    const counts = xor3Counts(values);
    for(const c of cells){
      if(!c) continue;
      if(c.faceup){
        c.locked=false;
        c.card.className='card faceup'; c.card.textContent=labelFor(c.value);
      }else{
        const cnt = counts.get(c.value)||0;
        if(cnt>0){
          c.locked=true;
          c.card.className='card locked'; c.card.textContent=String(cnt);
        }else{
          c.locked=false;
          c.card.className='card facedown'; c.card.textContent='';
        }
      }
    }
  }

  // ----- Basis mode -----

  function combXor(values, k){
    const n = values.length; const out = new Set();
    function rec(start, need, acc){
      if(need===0){ out.add(acc); return; }
      for(let i=start; i<=n-need; i++) rec(i+1, need-1, acc ^ values[i]);
    }
    if(k<=n) rec(0, k, 0);
    return out;
  }
  function oddXorSetGT3(values){
    const n = values.length; const res = new Set();
    for(let k=5; k<=n; k+=2){
      for(const x of combXor(values, k)) res.add(x);
    }
    return res;
  }
  function updatePileHintsGT3(){
    try{
      // Use values of already placed basis cards (red cells)
      const placedVals = [];
      for(const [pos, val] of basisAssignments.entries()){
        if(popcount(pos) <= 1) placedVals.push(val);
      }
      const disabledVals = oddXorSetGT3(placedVals);
      const nodes = pile ? pile.querySelectorAll('.draggable') : [];
      nodes.forEach(el => {
        const v = parseInt(el.id.replace('pile-',''),10);
        if(disabledVals.has(v)){
          el.classList.add('pile-disabled'); el.draggable = false;
          el.title = 'Odd XOR of already placed basis cards (size ≥5): cannot be a basis card.';
        }else{
          el.classList.remove('pile-disabled'); el.draggable = true; el.title='';
        }
      });
    }catch(e){ console.warn('updatePileHintsGT3 error', e); }
  }
  // Prevent dragging disabled pile items
  document.addEventListener('dragstart', function(ev){
    const el = ev.target;
    if(el && el.classList && el.classList.contains('pile-disabled')){
      ev.preventDefault();
    }
  }, true);

  let basisMode=false;
  let basisAssignments = new Map(); // pos -> value
  let chipPlacedValues = new Set(); // values actually placed as chips
  function isBasisPos(p){ return popcount(p) <= 1; } // 0 and powers of 2

  function enterBasisMode(){
    updateButtonStates();
    updateClearButtonState();
    const t=document.getElementById('editToggle');
    if(t){ t.checked=false; t.disabled=true; setEditEnabled(false);
      const lab=t.closest('label'); if(lab) lab.classList.add('disabled'); }
    basisMode=true;
    updateButtonStates();
    basisAssignments.clear();
    chipPlacedValues.clear();
    // Build pile from current face-up VALUES
    const pileValues = Array.from(faceUpPositions).map(p => cells[p].value);
    // Clear the grid visuals (turn cards facedown and clear text)
    cells.forEach(c => {
      if(!c) return;
      c.faceup=false; c.locked=false; c.card.className='card facedown'; c.card.textContent='';
      const target = isBasisPos(c.pos);
      c.cell.classList.toggle('basisTarget', target);
      if(target){
        c.cell.ondragover=(e)=>{e.preventDefault();};
        c.cell.ondrop=(e)=>{
          e.preventDefault();
          const val=parseInt(e.dataTransfer.getData('text/plain'),10);
          if(isNaN(val)) return;
          if(basisAssignments.has(c.pos)) return;
          basisAssignments.set(c.pos,val);
          chipPlacedValues.add(val);
          attachChip(c, val);
          removeFromPile(val);
          maybeFinishBasis(pileValues);
          updatePileHintsGT3();
        };
      }else{ c.cell.ondragover=null; c.cell.ondrop=null; }
    });

    // show pile
    pileWrap.style.display='block';
    pile.innerHTML='';
    pileValues.forEach(v => addPileCard(v));
    layoutToFit();
  
    updatePileHintsGT3();
}

  function addPileCard(v){
    const d=document.createElement('div');
    d.className='draggable';
    d.draggable=true;
    d.id='pile-'+v;
    d.textContent=labelFor(v);
    d.ondragstart=(e)=>{ e.dataTransfer.setData('text/plain', String(v)); };
    pile.appendChild(d);
  }
  function removeFromPile(v){
    const n=document.getElementById('pile-'+v);
    if(n) n.remove();
  }
  function attachChip(cellObj, val){
    const chip=document.createElement('div');
    chip.className='basisChip';
    chip.textContent='card '+labelFor(val);
    const x=document.createElement('span');
    x.className='chipRem';
    x.textContent='×';
    x.title='Remove';
    x.onclick=()=>{
      // remove assignment and return to pile
      basisAssignments.delete(cellObj.pos);
      chipPlacedValues.delete(val);
      chip.remove();
      addPileCard(val);
      maybeFinishBasis(Array.from(pile.querySelectorAll('.draggable')).map(n=>parseInt(n.id.replace('pile-',''),10)));
      updatePileHintsGT3();
    };
    chip.appendChild(x);
    cellObj.cell.appendChild(chip);
  }

  function maybeFinishBasis(originalPileValues){
    const remaining = pile.querySelectorAll('.draggable').length;
    const totalTargets = cells.filter(Boolean).filter(c=>isBasisPos(c.pos)).length;
    const filled = basisAssignments.size;
    if(remaining===0 || filled>=totalTargets){
      updatePileHintsGT3();
      finishBasis(originalPileValues);
    }
  }

  function finishBasis(originalPileValues){

    // 2) Compute grid values using odd-sum rule (include 0 to make count odd)
    const zeroVal = basisAssignments.get(0);
    const onePositions = Array.from(basisAssignments.keys()).filter(k=>k!==0);
    for(let p=0;p<DECK;p++){
      let acc=0, used=0;
      for(const bp of onePositions){
        if((p & bp)!==0){ acc ^= basisAssignments.get(bp); used++; }
      }
      if(used % 2 === 0 && zeroVal !== undefined){
        acc ^= zeroVal; used++;
      }
      cells[p].value = acc;
    }
    // Build value->position map for reliable placement
    const valueToPos = new Map();
    for(const c of cells){ if(!c) continue; valueToPos.set(c.value, c.pos); }

    // 3) Place any face-up cards LEFT IN PILE onto their computed locations face up
    const leftover = Array.from(pile.querySelectorAll('.draggable')).map(n=>parseInt(n.id.replace('pile-',''),10));
    faceUpPositions.clear();
    cells.forEach(c => { c.faceup=false; c.card.className='card facedown'; c.card.textContent=''; });
    // Cards used as placed basis chips should be face up at their targets
    basisAssignments.forEach((val, pos) => {
      if(chipPlacedValues.has(val)){
        const c = cells[pos];
        c.faceup=true; faceUpPositions.add(pos);
        c.card.className='card faceup'; c.card.textContent=labelFor(c.value);
      }
    });
    // Leftover pile face-ups go to their computed positions by lookup
    leftover.forEach(v => {
      const pos = valueToPos.get(v);
      if(pos !== undefined){
        const c = cells[pos];
        c.faceup=true; faceUpPositions.add(pos);
        c.card.className='card faceup'; c.card.textContent=labelFor(c.value);
      }
    });

    // 4) All other positions already facedown with correct values

    // 5) Re-run lock algorithm
    updateLocks();

    // Exit basis UI
    cells.forEach(c=>{
      if(!c) return;
      c.cell.classList.remove('basisTarget');
      c.cell.ondragover=null;
      c.cell.ondrop=null;
      const chip=c.cell.querySelector('.basisChip'); if(chip) chip.remove();
    });
    pileWrap.style.display='none';
    pile.innerHTML='';
    basisMode=false;
    updateButtonStates();
    updateClearButtonState();
    const t=document.getElementById('editToggle');
    if(t){ t.disabled=false; const lab=t.closest('label'); if(lab) lab.classList.remove('disabled'); setEditEnabled(false); }
    layoutToFit();
  }

  
  function revealRedLocations(){
    if(basisMode || !editEnabled) return;
    if(faceUpPositions.size !== 0) return;
    let added = 0;
    for(const c of cells){
      if(!c) continue;
      const isRed = (popcount(c.pos) <= 1); // 0 and powers of 2
      if(isRed && !c.locked){
        c.faceup = true;
        faceUpPositions.add(c.pos);
        c.card.className = 'card faceup';
        c.card.textContent = labelFor(c.value);
        added++;
      }
    }
    updateLocks();
    updateClearButtonState();
    updateButtonStates();
  }

  // Return to standard locations
  function returnToStandard(){
    // Determine the exact set of face-up CARD VALUES to preserve
    let faceUpValues;
    if(basisMode){
      // In basis mode: union of placed chip values and pile leftovers
      const pileVals = Array.from(pile.querySelectorAll('.draggable')).map(n=>parseInt(n.id.replace('pile-',''),10));
      faceUpValues = Array.from(new Set([...chipPlacedValues, ...pileVals]));
    }else{
      // Normal mode: values currently face up on the grid
      faceUpValues = Array.from(faceUpPositions).map(p => cells[p].value);
    }
    // Reset mapping to standard
    cells.forEach(c => c.value = c.pos);
    // Clear visuals and apply preserved face-up set at native locations
    faceUpPositions.clear();
    cells.forEach(c => { c.faceup=false; c.card.className='card facedown'; c.card.textContent=''; });
    faceUpValues.forEach(v => {
      if(v>=0 && v<DECK){
        const c=cells[v];
        c.faceup=true; faceUpPositions.add(c.pos);
        c.card.className='card faceup'; c.card.textContent=labelFor(c.value);
      }
    });
    // Exit basis UI if we were in it
    if(basisMode){
      cells.forEach(c=>{ if(!c) return; c.cell.classList.remove('basisTarget'); c.cell.ondragover=null; c.cell.ondrop=null; const chip=c.cell.querySelector('.basisChip'); if(chip) chip.remove(); });
      pileWrap.style.display='none';
      pile.innerHTML='';
      basisMode=false;
      basisAssignments.clear();
      chipPlacedValues.clear();
    }
    updateLocks();
    updateButtonStates();
    updateClearButtonState();
    updateButtonStates();
  }

  // Clear current cards: turn all facedown and clear locks
  function clearCurrentCards(){
    faceUpPositions.clear();
    cells.forEach(c => {
      if(!c) return;
      c.faceup = false;
      c.locked = false;
      c.card.className = 'card facedown';
      c.card.textContent = '';
    });
    updateLocks();
    updateClearButtonState();
  updateButtonStates();
  }
  // Randomly assign pile cards to unfilled basis targets (basis mode only)
  function randomBasis(){
    if(!basisMode) return;

    // Determine basis targets that are not yet filled (includes 0 and unit positions)
    const targets = cells.filter(Boolean).filter(c => isBasisPos(c.pos) && !basisAssignments.has(c.pos));

    // Snapshot the current visible pile values (face-up)
    const originalPileValues = Array.from(pile.querySelectorAll('.draggable')).map(n=>parseInt(n.id.replace('pile-',''),10));

    // Shuffle a working list so selection order is random but constraints are respected
    const work = originalPileValues.slice();
    for(let i=work.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      const tmp = work[i]; work[i] = work[j]; work[j] = tmp;
    }

    // Helper: compute the disallowed set using the same rule as the UI hints
    function currentDisabledSet(){
      const placedVals = [];
      for(const [pos, val] of basisAssignments.entries()){
        if(popcount(pos) <= 1) placedVals.push(val);
      }
      return oddXorSetGT3(placedVals); // odd XOR of size >=5 of already placed basis cards
    }

    // Step through exactly like the user: at each step, skip disabled pile cards
    for(const t of targets){
      // Recompute disabled set with *current* placed basis values
      const disabled = currentDisabledSet();

      // Find the first available pile value that is not disabled
      let pickIndex = -1;
      for(let i=0;i<work.length;i++){
        if(!disabled.has(work[i])){ pickIndex = i; break; }
      }
      if(pickIndex === -1) break; // no valid card left; stop early

      const val = work.splice(pickIndex,1)[0];

      // Place it on the basis target exactly like a user drop
      basisAssignments.set(t.pos, val);
      chipPlacedValues.add(val);
      attachChip(t, val);
      removeFromPile(val);

      // Keep the UI rules in sync (even though this selection is invisible to the user)
      updatePileHintsGT3();
    }

    // Decide whether we're done
    const totalTargets = cells.filter(Boolean).filter(c=>isBasisPos(c.pos)).length;
    const filled = basisAssignments.size;
    if(filled >= totalTargets || pile.querySelectorAll('.draggable').length === 0){
      updatePileHintsGT3();
      finishBasis(originalPileValues);
    }
  }

  
  // --- Analyze Card feature ---
  const analyzeBtn = document.getElementById('analyzeBtn');
  const analyzeHint = document.getElementById('analyzeHint');
  const analysisPanel = document.getElementById('analysisPanel');
  const analysisResults = document.getElementById('analysisResults');
  let analyzeMode = false;
  let lastAnalyzePos = null;

  function setAnalyzeMode(on){
    analyzeMode = !!on;
    // manage button style and label
    if(analyzeBtn){
      analyzeBtn.classList.toggle('active', analyzeMode);
      analyzeBtn.textContent = analyzeMode ? 'Exit Analyze' : 'Analyze Card';
    }
    // disable edit mode while analyzing; restore on exit
    try{
      const editToggle = document.getElementById('editToggle');
      if(typeof setAnalyzeMode._prevEdit === 'undefined'){
        setAnalyzeMode._prevEdit = editToggle ? !!editToggle.checked : true;
      }
      if(analyzeMode){
        if(editToggle){ editToggle.disabled = true; editToggle.checked = false; }
        setEditEnabled(false);
      }else{
        if(editToggle){ editToggle.disabled = false; editToggle.checked = !!setAnalyzeMode._prevEdit; }
        setEditEnabled(!!setAnalyzeMode._prevEdit);
        delete setAnalyzeMode._prevEdit;
        // clear highlight and panel text
        document.querySelectorAll('.analyzeTarget').forEach(el => el.classList.remove('analyzeTarget'));
        if(analysisPanel){ analysisPanel.style.display = 'none'; }
      }
    }catch(e){ /* no-op */ }

    // Hint + panel visibility
    if(analyzeHint) analyzeHint.style.display = analyzeMode ? 'inline' : 'none';
    if(analysisPanel) analysisPanel.style.display = analyzeMode ? 'block' : 'none';
    if(analysisResults && analyzeMode){
      analysisResults.innerHTML = '<em>Analyze mode is ON. Click a <strong>face‑up</strong> card to analyze.</em>';
    }
  }
      analyzeBtn?.addEventListener('click', ()=> setAnalyzeMode(!analyzeMode));

  // Click handling on grid cells
  grid.addEventListener('click', (e)=>{
    if(!analyzeMode) return;
    const cellEl = e.target.closest('.cell');
    if(!cellEl) return;
    const pos = parseInt(cellEl.dataset.pos, 10);
    const c = cells[pos];
    if(!c || !c.faceup){
      if(analysisResults) analysisResults.textContent = 'Please click a face‑up card.';
      return;
    }
    // highlight the target card
    document.querySelectorAll('.analyzeTarget').forEach(el => el.classList.remove('analyzeTarget'));
    (c.card || cellEl.querySelector('.card') || cellEl).classList.add('analyzeTarget');
    // show panel and compute
    if(analysisPanel) analysisPanel.style.display = 'block';
    lastAnalyzePos = pos;
    analyzeOddXorRepresentations(pos);
    try{ analysisPanel.scrollIntoView({behavior:'smooth', block:'nearest'}); }catch(_){}
  });

  function analyzeOddXorRepresentations(targetPos){
    lastAnalyzePos = targetPos;
    const targetVal = cells[targetPos].value;
    // Collect other face-up values
    const items = [];
    cells.forEach(cc => {
      if(!cc) return;
      if(cc.faceup && cc.pos !== targetPos){
        items.push({pos: cc.pos, val: cc.value});
      }
    });

    const MAX_SOLUTIONS = 1000;
    const MAX_VISITS = 200000;
    let solutions = [];
    let visits = 0;

    // Backtracking to enumerate odd-size subsets whose XOR == targetVal
    function dfs(start, accXor, chosen){
      if(visits++ > MAX_VISITS) return;
      if(chosen.length % 2 === 1 && accXor === targetVal){
        solutions.push(chosen.slice());
        if(solutions.length >= MAX_SOLUTIONS) return;
      }
      // pruning by size could be added if needed
      for(let i=start; i<items.length; i++){
        if(solutions.length >= MAX_SOLUTIONS) return;
        chosen.push(items[i]);
        dfs(i+1, accXor ^ items[i].val, chosen);
        chosen.pop();
      }
    }
    dfs(0, 0, []);

    // Render results
    if(!analysisResults) return;
    function fmtCard(x){ return labelFor(x); }
    function posBin(p){ return p.toString(2); }

    if(solutions.length === 0){
      analysisResults.innerHTML = `<div><strong>Target:</strong> ${fmtCard(targetVal)}</div><div>No odd XOR representations found using the other face‑up cards.</div>`;
      return;
    }
    const capped = solutions.length >= MAX_SOLUTIONS;
    const bySize = new Map();
    for(const sol of solutions){
      const k = sol.length;
      if(!bySize.has(k)) bySize.set(k, []);
      bySize.get(k).push(sol);
    }
    let htmlOut = `<div><strong>Target:</strong> ${fmtCard(targetVal)}</div>`;
    if(capped){
      htmlOut += `<div class="muted">Showing first ${MAX_SOLUTIONS} solutions (search capped). Try reducing face‑up cards if you want all solutions.</div>`;
    }else{
      htmlOut += `<div class="muted">Found ${solutions.length} solution(s).</div>`;
    }
    const sizes = Array.from(bySize.keys()).sort((a,b)=>a-b);
    for(const k of sizes){
      htmlOut += `<details><summary><strong>${k}</strong> card${k>1?'s':''}</summary>`;
      const arr = bySize.get(k);
      htmlOut += `<ol style="margin-top:6px">`;
      for(const sol of arr){
        const parts = sol.map(o => `${fmtCard(o.val)}`);
        htmlOut += `<li>${fmtCard(targetVal)} = ${parts.join(' ⊕ ')}</li>`;
      }
      htmlOut += `</ol></details>`;
    }
    analysisResults.innerHTML = htmlOut;
  }

  // keyboard: Esc exits analyze mode
  window.addEventListener('keydown', (ev)=>{ if(ev.key==='Escape' && analyzeMode){ setAnalyzeMode(false); }});

  // wiring
  deckSel.addEventListener('change', e => { DECK = parseInt(e.target.value, 10);
  // Reset all state as if entering app fresh
  try{
    // exit analyze mode
    if(typeof analyzeMode !== 'undefined' && analyzeMode){ setAnalyzeMode(false); }
    if(typeof lastAnalyzePos !== 'undefined') lastAnalyzePos = null;
    // exit basis mode and clear pile/grid decorations
    basisMode = false;
    basisAssignments.clear();
    chipPlacedValues.clear();
    pileWrap.style.display='none';
    pile.innerHTML='';
  }catch(_){}
  // reset mapping and faceups
  faceUpPositions.clear();
  cells.forEach(c => { if(!c) return; c.value = c.pos; });
  // ensure editing is enabled
  const et = document.getElementById('editToggle');
  if(et){ et.disabled = false; et.checked = true; }
  setEditEnabled(true);
  // finally rebuild
  rebuild();
  updateClearButtonState();
  updateButtonStates();
  updateButtonStates();
  updateClearButtonState(); });
  document.getElementById('editToggle').addEventListener('change', e => setEditEnabled(e.target.checked));
  setEditEnabled(true);

  binaryToggle.addEventListener('change', e => { 
    showBinary = !!e.target.checked;
    cells.forEach(c=>{ if(c?.faceup){ c.card.textContent = labelFor(c.value); } });

  // Re-render analysis to match binary toggle
  try{ if(typeof lastAnalyzePos !== 'undefined' && lastAnalyzePos !== null){ analyzeOddXorRepresentations(lastAnalyzePos); } }catch(_){ }
    // update pile labels
    pile.querySelectorAll('.draggable').forEach(n=>{
      const v=parseInt(n.id.replace('pile-',''),10);
      n.textContent=labelFor(v);
    });
    // update any existing chips
    cells.forEach(c=>{
      const chip=c?.cell?.querySelector?.('.basisChip');
      if(chip){
        const txt=chip.firstChild; // text node
        if(txt) chip.childNodes[0].nodeValue='card '+labelFor(basisAssignments.get(c.pos))+' ';
      }
    });
  });
  newBasisBtn.addEventListener('click', enterBasisMode);
  returnStdBtn.addEventListener('click', returnToStandard);
  const randomBtn = document.getElementById('randomBasisBtn');
  randomBtn.addEventListener('click', () => { if(!basisMode) enterBasisMode(); randomBasis(); });
  
  document.getElementById('clearCardsBtn').addEventListener('click', clearCurrentCards);
  document.getElementById('revealRedBtn').addEventListener('click', revealRedLocations);
  window.addEventListener('resize', layoutToFit);

  rebuild();
  updateClearButtonState();
  updateButtonStates();
  updateButtonStates();
  updateClearButtonState();

  // --- Bases tools (Count Only / List N) ---
  const countBasesBtn = document.getElementById('countBasesBtn');
  const listNInput = document.getElementById('listNInput');
  const listBasesOnScreenBtn = document.getElementById('listBasesOnScreenBtn');
  const listBasesCsvBtn = document.getElementById('listBasesCsvBtn');
  const basesPanel = document.getElementById('basesPanel');
  const basesResults = document.getElementById('basesResults');
  const basesMeta = document.getElementById('basesMeta');

  function basisSizeNeeded(){ return 1 + bitsForDeck(DECK); } // 0 plus unit vectors

  function currentFaceUpValues(){
    const arr = [];
    faceUpPositions.forEach(p => { const c = cells[p]; if(c && c.faceup) arr.push(c.value); });
    arr.sort((a,b)=>a-b);
    return arr;
  }

  // Compute up to a limit "limitN" of bases, or count only if limitN === 0
  function enumerateBases(limitN){
    const need = basisSizeNeeded();
    const cand = currentFaceUpValues();
    const n = cand.length;
    const disabledCache = new Map(); // memo for oddXorSetGT3 on pick-sets (by key)

    const solutions = [];
    let count = 0;

    function keyFor(picks){ return picks.join(','); }
    function disabledFrom(picks){
      const k = keyFor(picks);
      if(disabledCache.has(k)) return disabledCache.get(k);
      const dis = oddXorSetGT3(picks.slice());
      disabledCache.set(k, dis);
      return dis;
    }

    function backtrack(start, picks){
      if(limitN > 0 && solutions.length >= limitN) return;
      if(picks.length === need){
        count++;
        if(limitN > 0) solutions.push(picks.slice());
        return;
      }
      if(start >= n) return;
      const remainingSlots = need - picks.length;
      const remainingCand = n - start;
      if(remainingCand < remainingSlots) return;

      const dis = disabledFrom(picks);
      for(let i=start; i<n; i++){
        const v = cand[i];
        if(picks.includes(v)) continue;
        if(dis.has(v)) continue;
        picks.push(v);
        backtrack(i+1, picks);
        picks.pop();
        if(limitN > 0 && solutions.length >= limitN) return;
      }
    }
    backtrack(0, []);
    return {need, count, solutions};
  }

  function renderListOnScreen(solutions, need){
    if(!basesPanel) return;
    basesPanel.style.display = 'block';
    basesMeta.textContent = `k = ${need} (showing ${solutions.length})`;
    if(solutions.length === 0){
      basesResults.innerHTML = '<div>No valid bases found (or not enough face‑up cards).</div>';
      return;
    }
    let out = '<ol style="margin-top:6px">';
    for(const sol of solutions){
      const parts = sol.map(v => labelFor(v));
      out += `<li>{ ${parts.join(', ')} }</li>`;
    }
    out += '</ol>';
    basesResults.innerHTML = out;
    try{ basesPanel.scrollIntoView({behavior:'smooth', block:'nearest'}); }catch(_){}
  }

  function downloadCSV(solutions, need){
    if(!solutions || solutions.length === 0){
      alert('No bases to export. Use "List on screen" first to generate some.');
      return;
    }
    const header = ['basis_id'].concat(Array.from({length:need}, (_,i)=>`card_${i+1}`)).join(',');
    const lines = [header];
    solutions.forEach((sol, idx)=>{
      const parts = sol.map(v => labelFor(v));
      lines.push([idx+1].concat(parts).join(','));
    });
    const csv = '\uFEFF' + lines.join('\r\n') + '\r\n'; // Excel-friendly
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `possible_bases_DECK${DECK}_k${need}_first${solutions.length}.csv`;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
  }

  countBasesBtn?.addEventListener('click', ()=>{
    const {need, count} = enumerateBases(0);
    if(basesPanel) basesPanel.style.display = 'block';
    if(basesMeta) basesMeta.textContent = `k = ${need}`;
    if(basesResults) basesResults.innerHTML = `<div><strong>Total bases:</strong> ${count.toLocaleString()}</div>`;
    try{ basesPanel.scrollIntoView({behavior:'smooth', block:'nearest'}); }catch(_){}
  });

  listBasesOnScreenBtn?.addEventListener('click', ()=>{
    const N = Math.max(1, parseInt((document.getElementById('listNInput')?.value || '50'), 10));
    const {need, solutions} = enumerateBases(N);
    renderListOnScreen(solutions, need);
  });

  listBasesCsvBtn?.addEventListener('click', ()=>{
    const N = Math.max(1, parseInt((document.getElementById('listNInput')?.value || '50'), 10));
    const {need, solutions} = enumerateBases(N);
    downloadCSV(solutions, need);
  });

  // Hide bases panel when deck changes
  document.getElementById('deck')?.addEventListener('change', ()=>{
    if(basesPanel) basesPanel.style.display = 'none';
    if(basesMeta) basesMeta.textContent = '';
    if(basesResults) basesResults.textContent = 'Results will appear here.';
  });

})(); 
</script>

</body>
</html>
