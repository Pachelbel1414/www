<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PME Seal</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>

  <script>

  // py -m http.server 8000
  // http://localhost:8000/test_pme_viz.html

  const scene = new THREE.Scene();

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  scene.background = new THREE.Color(0xcccccc);

  // Lighting
  const light = new THREE.DirectionalLight(0xffffff, 1.8);
  light.position.set(0, 20, -20);
  light.target.position.set(0, 5, 5);
  light.castShadow = true;
  scene.add(light);

  const ambient = new THREE.AmbientLight(0xffffff, 0.3);
  scene.add(ambient);
  const hemi = new THREE.HemisphereLight(0xffeebb, 0x080820, 0.8);
  scene.add(hemi);

  // -------------------------
  // Metallic gold material
  var goldMaterial = new THREE.MeshStandardMaterial({
    color: 0xFFD700,      // gold color
    metalness: 1.0,       // fully metallic
    roughness: 0.3        // slight surface roughness
  });

  var goldMaterial2 = new THREE.MeshPhongMaterial({
    color: 0x7f6e05,
    //color: 0xffd700,
    shininess: 50,
    specular: 0xffffff
  });

  const goldMaterial3 = new THREE.MeshStandardMaterial({
    alphaTest: 0.5,
    color: 0xF6D97E,        // brighter yellow-gold
    metalness: 1.0,
    roughness: 0.1,         // sharper shine
    emissive: 0x8A6C10,     // soft warm gold-brown glow
    emissiveIntensity: 0.5,
    envMapIntensity: 2.0,
    side: THREE.DoubleSide,
  });

  // -------------------------
  // Purple disk with thickness — short cylinder
  var radius = 15.8;         // disk radius
  var thickness = 0.40;     // disk thickness (height of cylinder)
  var radialSegments = 64;  // smooth edge

  var geom = new THREE.CylinderGeometry(radius, radius, thickness, radialSegments, 1, false);
  var mat  = new THREE.MeshPhongMaterial({ color: 0x240d4b, shininess: 30 });
  var disk = new THREE.Mesh(geom, mat);

  disk.position.set(0, 0, 0);   // raise height here
  scene.add(disk);

  // -------------------------
  // Triangle shape
  var triangleShape = new THREE.Shape();
  const tri = 0.5;
  triangleShape.moveTo(0, tri + 0.2);
  triangleShape.lineTo(-tri, 0);
  triangleShape.lineTo(tri, 0);
  triangleShape.lineTo(0, tri + 0.2);

  // Extrude to give thickness
  // Extrude with bevel
  var extrudeSettings = {
    depth: 0.1,
    bevelEnabled: true,
    bevelThickness: 0.20,   // how much upward
    bevelSize: 0.6,         // how much inward from edge
    bevelSegments: 8
  };
  var triangelGeo = new THREE.ExtrudeGeometry(triangleShape, extrudeSettings);
  var triangle = new THREE.Mesh(triangelGeo, goldMaterial2);

  // there are 55 in original seal
  var count  = 55;      // how many triangles
  var radius = 15.9;

  for (var i = 0; i < count; i++) {
    var angle = (i / count) * Math.PI * 2;

    var t = triangle.clone();
    t.position.set(
      Math.sin(angle) * radius, // x
      0,                        // y
      -Math.cos(angle) * radius // z (starts at 0,0,-16 when angle=0)
    );

    t.rotation.x = -Math.PI / 2; // keep flat
    t.rotation.z = -angle;        // spin around to align around the circle

    scene.add(t);
  }

  // -------------------------
  var loader = new THREE.FontLoader();
  // loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
  loader.load('Merriweather_48pt_Medium_Regular.typeface.json', function (font) {

    var radius = 11.4;
    var text = 'PI MU EPSILON INCORPORATED';
    var count = text.length;

    angle = -120;   // start angle
    for (var i = 0; i < count; i++) {
      var char = text[i];

      var angle_d = (245.0 / count);
      if ([' '].includes(char))             angle_d *= 0.55;
      else if (['I'].includes(char))        angle_d *= 0.65;
      else if (['C', 'E', 'L', 'P', 'S'].includes(char))   angle_d *= 0.9;
      else if (['R'].includes(char))        angle_d *= 1.1;
      else if (['M', 'W'].includes(char))   angle_d *= 1.45;
      angle_d *= 1.1;

      angle_r = angle * Math.PI / 180.0
      angle += angle_d

      if (char === ' ') continue; // skip spaces

      var textGeo = new THREE.TextGeometry(char, {
        font: font,
        size: 1.9,
        height: 0.25,
        curveSegments: 6,
        bevelEnabled: true,
        bevelThickness: 0.09,  // how much upward
        bevelSize: 0.04,   // how much inward from edge
        bevelOffset: 0,
        bevelSegments: 8
      });

      var mesh = new THREE.Mesh(textGeo, goldMaterial2);

      // position around circle
      mesh.position.set(
        Math.sin(angle_r) * radius,
        0,
        -Math.cos(angle_r) * radius
      );

      // rotate so it faces outward
      mesh.rotation.x = -Math.PI / 2; // keep flat
      mesh.rotation.z = -angle_r - (angle_d * Math.PI / 180.0 / 2);

      scene.add(mesh);
    }
  });

  // -------------------------
  // create a 2D shape for the tilde (~)
  var tildeShape = new THREE.Shape();
  tildeShape.moveTo(0, 5);     // top left
  tildeShape.bezierCurveTo(3, 5, 3.75, 4, 4.75, 2.5);  
  tildeShape.bezierCurveTo(5.25, 1.4, 6.5, 0.75, 8, 0);  
  tildeShape.bezierCurveTo(4.5, 0, 3.5, 0.5, 2.5, 2.5);  
  tildeShape.bezierCurveTo(2, 3.5, 1, 4.5, 0, 5);  
  tildeShape.closePath();

  // Extrude with bevel
  var tildeExtrude = {
    depth: 0.10,
    bevelEnabled: true,
    bevelThickness: 0.4,   // how much upward
    bevelSize: 0.35,         // how much inward from edge
    bevelSegments:10
  };

  var tildeGeom = new THREE.ExtrudeGeometry(tildeShape, tildeExtrude);

  const s = 0.25;
  tildeGeom.scale(s, s, s); // scale all axes equally

  var tildeMesh = new THREE.Mesh(tildeGeom, goldMaterial2);
  tildeMesh.rotation.x = -Math.PI / 2; // keep flat

  // there are 69 in original seal
  var count  = 69;      // how many tildes
  var radius = 14.0;

  for (var i = 0; i < count; i++) {
    var angle = (i / count) * Math.PI * 2;

    var t = tildeMesh.clone();
    t.position.set(
      Math.sin(angle) * radius, // x
      0.2,                        // y
      -Math.cos(angle) * radius // z (starts at 0,0,-16 when angle=0)
    );

    t.rotation.x = -Math.PI / 2; // keep flat
    t.rotation.z = -angle - 0.0;        // spin around to align around the circle

    scene.add(t);
  }

  // -------------------------
  // geometry: radius, widthSegments, heightSegments
  var sphereGeo = new THREE.SphereGeometry(0.15, 16, 16);

  // mesh
  var sphereMesh = new THREE.Mesh(sphereGeo, goldMaterial2);

  // there are 133 in original seal
  var count  = 133;      // how many spheres
  var radius = 10.0;

  for (var i = 0; i < count; i++) {
    var angle = (i / count) * Math.PI * 2;

    var t = sphereMesh.clone();
    t.position.set(
      Math.sin(angle) * radius, // x
      0.20,                        // y
      -Math.cos(angle) * radius // z (starts at 0,0,-16 when angle=0)
    );

    t.rotation.x = -Math.PI / 2; // keep flat
    t.rotation.z = -angle;        // spin around to align around the circle

    scene.add(t);
  }

  // -------------------------
  // seven stars on bottom half
  var starShape = new THREE.Shape();
  var outerRadius = 0.9;
  var innerRadius = 0.35;
  var spikes = 5;
  var rot = Math.PI / 2 * 3;
  var step = Math.PI / spikes;

  starShape.moveTo(outerRadius * Math.cos(rot), outerRadius * Math.sin(rot));
  for (var i = 0; i < spikes; i++) {
    starShape.lineTo(Math.cos(rot) * outerRadius, Math.sin(rot) * outerRadius);
    rot += step;

    starShape.lineTo(Math.cos(rot) * innerRadius, Math.sin(rot) * innerRadius);
    rot += step;
  }
  starShape.closePath();

  // Extrude with bevel
  var starExtrude = {
    depth: 0.0,
    bevelEnabled: true,
    bevelThickness: 0.25,   // how much upward
    bevelSize: 0.25,         // how much inward from edge
    bevelSegments:10
  };

  var starGeo = new THREE.ExtrudeGeometry(starShape, starExtrude);

  var starMesh = new THREE.Mesh(starGeo, goldMaterial2);

  var count  = 7;      // how many stars
  var radius = 12.3;

  var start = 132;
  var sweep = 114;
  for (var i = 0; i < count; i++) {
    var angle = (start + (sweep * (i / count))) * Math.PI / 180.0;

    var t = starMesh.clone();
    t.position.set(
      Math.sin(angle) * radius, // x
      0.055,                        // y
      -Math.cos(angle) * radius // z (starts at 0,0,-16 when angle=0)
    );

    t.rotation.x = -Math.PI / 2; // keep flat
    t.rotation.z = Math.PI;       // spin around to align around the circle

    scene.add(t);
  }

  // -------------------------
  // rocket
  var r_sc = 0.022857143 + .002;
  var r_ht = (525 * r_sc) / 2;
  var r_wd = (185 * r_sc) / 2;
  var r_b_ht = r_ht - (55 * r_sc);
  var w_ht = (290 * r_sc);
  var w_wd = r_wd + (160 * r_sc);

  const outer = new THREE.Shape()
    .moveTo(-r_wd, -r_ht)
    .lineTo(r_wd, -r_ht)
      .lineTo(r_wd, -r_b_ht)
      .lineTo(w_wd, -r_b_ht)
      .lineTo(r_wd, -r_b_ht + w_ht)
    .lineTo(r_wd, r_ht)
    .lineTo(-r_wd, r_ht)
      .lineTo(-r_wd, -r_b_ht + w_ht)
      .lineTo(-w_wd, -r_b_ht)
      .lineTo(-r_wd, -r_b_ht)
    .lineTo(-r_wd, -r_ht);

  var in_ht = 6.3;
  var in_wd = 2.10;
  const inner = new THREE.Path()
    .moveTo(-in_wd, -in_ht)
    .lineTo(in_wd, -in_ht)
    .lineTo(in_wd, in_ht)
    .lineTo(-in_wd, in_ht)
    .lineTo(-in_wd, -in_ht);

  const innerRight = new THREE.Path()
    .moveTo(2.35, -4.7)
    .lineTo(5.2, -4.6)
    .lineTo(2.47, 0.3)
    .lineTo(2.35, -4.6);

  const innerLeft = new THREE.Path()
    .moveTo(-2.35, -4.7)
    .lineTo(-5.2, -4.6)
    .lineTo(-2.47, 0.3)
    .lineTo(-2.35, -4.6);

  outer.holes.push(inner);
  outer.holes.push(innerRight);
  outer.holes.push(innerLeft);

  // Extrude with bevel
  var rocketExtrude = {
    depth: 0.0,
    bevelEnabled: true,
    bevelThickness: 0.25,   // how much upward
    bevelSize: 0.25,         // how much inward from edge
    bevelSegments:10
  };

  // ✅ use the shape directly, not ShapeGeometry
  var rocketGeo = new THREE.ExtrudeGeometry(outer, rocketExtrude);
  const rocketMesh = new THREE.Mesh(rocketGeo, goldMaterial2);
  rocketMesh.rotation.x = -Math.PI / 2; // lay it flat

  rocketMesh.position.set(0, 0.075, 0);

  scene.add(rocketMesh);

  // -------------------------
  // PME in center of rocket
  var loader = new THREE.FontLoader();
  loader.load('Manrope_Medium_Regular.typeface.json', function (font) {

    var text = 'πME';
    var count = text.length;

    for (var i = 0; i < count; i++) {
      var char = text[i];

      var b_adj = 0;
      if (char == 'M')  b_adj = 0.15;
      if (char == 'E')  b_adj = 0.01;

      var textGeo = new THREE.TextGeometry(char, {
        font: font,
        size: 2.5,
        height: 0.15,
        curveSegments: 6,
        bevelEnabled: true,
        bevelThickness: 0.19,  // how much upward
        bevelSize: 0.09 + b_adj,   // how much inward from edge
        bevelOffset: 0,
        bevelSegments: 8
      });

      var mesh = new THREE.Mesh(textGeo, goldMaterial2);

      var targetWidth = 2.5;
      var targetHeight = 2.6;

      if (char == 'π')  {
        targetWidth = 2.65;
        targetHeight = 2.75;
      }
      if (char == 'M')  targetWidth = 2.55;

      var x_adj = 0;
      var z_adj = 0;
      if (char == 'M')  {
        x_adj = 0.05;
        z_adj = -0.1;
      }
      if (char == 'E')  x_adj = -0.15;

      textGeo.computeBoundingBox();
      const size = textGeo.boundingBox.getSize(new THREE.Vector3());
      mesh.scale.set(targetWidth / size.x, targetHeight / size.y, 1);

      // position around circle
      mesh.position.set(
        -1.3 + x_adj,
        0,
        -2.55 + ( i * 3.8) + z_adj,
      );

      // rotate so it faces outward
      mesh.rotation.x = -Math.PI / 2; // keep flat
      mesh.rotation.z = 0;

      scene.add(mesh);
    }
  });

  // -------------------------
  // add a grid to help with the view visualization
  const grid = new THREE.GridHelper(48, 48);
  //scene.add(grid);

  // -------------------------
  // add export button

  // Assume `scene` contains your model, or just pass the specific mesh:
  const exporter = new THREE.STLExporter();

  // --- create the button ---
  const exportBtn = document.createElement('button');
  exportBtn.textContent = 'Export STL';
  exportBtn.style.position = 'absolute';
  exportBtn.style.top = '10px';
  exportBtn.style.left = '10px';
  exportBtn.style.zIndex = '1000';
  exportBtn.style.padding = '8px 12px';
  exportBtn.style.fontFamily = 'sans-serif';
  exportBtn.style.cursor = 'pointer';
  document.body.appendChild(exportBtn);

  exportBtn.addEventListener('click', () => {

    const tempGroup = new THREE.Group();
    const clonedScene = scene.clone(true);
    tempGroup.add(clonedScene);

    // Apply scale
    const exportScale = 1.65;
    tempGroup.scale.set(exportScale, exportScale, exportScale);

    // Apply rotation (in radians)
    tempGroup.rotation.x = Math.PI / 4; // rotate 90° around X
    // tempGroup.rotation.y = ...
    // tempGroup.rotation.z = ...

    // Update transforms
    tempGroup.updateMatrixWorld(true);

    // Bake transforms into geometry
    tempGroup.traverse(obj => {
      if (obj.isMesh) {
        obj.geometry = obj.geometry.clone(); // ensure we don't mutate original geometry
        obj.geometry.applyMatrix4(obj.matrixWorld);
        obj.matrix.identity();
        obj.position.set(0, 0, 0);
        obj.rotation.set(0, 0, 0);
        obj.scale.set(1, 1, 1);
      }
    });

    // Clear baked world matrices
    tempGroup.updateMatrixWorld(true);
    // Export
    const stlString = exporter.parse(tempGroup);

    const blob = new Blob([stlString], { type: 'text/plain' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'model.stl';
    link.click();

    URL.revokeObjectURL(link.href);
  });

  // -------------------------
  // --- create square high-res PNG export button ---
  const pngBtn = document.createElement('button');
  pngBtn.textContent = 'Export PNG (Square Flat View)';
  pngBtn.style.position = 'absolute';
  pngBtn.style.top = '50px';
  pngBtn.style.left = '10px';
  pngBtn.style.zIndex = '1000';
  pngBtn.style.padding = '8px 12px';
  pngBtn.style.fontFamily = 'sans-serif';
  pngBtn.style.cursor = 'pointer';
  document.body.appendChild(pngBtn);

  pngBtn.addEventListener('click', () => {
    // --- configuration ---
    const targetSize = 1024;  // base render size
    const scale = 2.0;        // 2× resolution (outputs 2048×2048 PNG)
    const size = targetSize * scale;

    // store original renderer settings
    const originalSize = renderer.getSize(new THREE.Vector2());
    const originalPixelRatio = renderer.getPixelRatio();

    // resize renderer to square high-res target
    renderer.setSize(size, size, false);
    renderer.setPixelRatio(originalPixelRatio * scale);

    // setup orthographic camera for flat projection
    const d = 20;
    const orthoCam = new THREE.OrthographicCamera(-d, d, d, -d, 0.1, 1000);
    orthoCam.position.set(0, 50, 0); // top-down view
    orthoCam.lookAt(0, 0, 0);

    // optional: clean lighting for flat render
    //const oldBg = scene.background;
    //scene.background = new THREE.Color(0xffffff); // white background
    //light.position.set(0, 20, 0);
    //light.intensity = 0.25;

    // render and export
    renderer.render(scene, orthoCam);

    const link = document.createElement('a');
    link.download = 'pme_flat_square.png';
    link.href = renderer.domElement.toDataURL('image/png');
    link.click();

    // restore settings
    scene.background = oldBg;
    renderer.setSize(originalSize.x, originalSize.y, false);
    renderer.setPixelRatio(originalPixelRatio);
    renderer.render(scene, camera);
  });


  // -------------------------
  // add view controls
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 28.25, 0);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;

  function animate() {
    requestAnimationFrame(animate);  // recursive
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  </script>
</body>
</html>
